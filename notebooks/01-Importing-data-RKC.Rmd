---
title: "01-Importing-data-Bowtie2"
author: "Laura H Spencer"
date: "01/09/2022"
output: html_document
---

In this notebook I will import gene counts file that were generated by Bowtie --> FeatureCounts 

### Check working directory 

```{r}
getwd()
```

### Load libraries and source scripts 

```{r, message=FALSE, warning=FALSE, results=FALSE}
# source("../references/biostats.R")

# Add all required libraries that are installed with install.packages() here
list.of.packages <- c("RCurl", "tidyverse", "vegan", "pheatmap", "pastecs", "factoextra", "FactoMineR", "RColorBrewer", "tibble", "reshape2", "plotly", "corrplot", "PerformanceAnalytics", "cowplot", "here", "janitor")
# Add all libraries that are installed using BiocManager here
bioconductor.packages <- c("DESeq2", "WGCNA")

# Install BiocManager if needed
if(!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
new.bioc.packages <- bioconductor.packages[!(bioconductor.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
if(length(new.bioc.packages)) BiocManager::install(new.bioc.packages)

# Load all required libraries
all.packages <- c(list.of.packages, bioconductor.packages)
lapply(all.packages, FUN = function(X) {
  do.call("require", list(X))
})

```

### Import sample info, library/file names, and then join 

```{r}
library.stats <- read.csv("../data/library-prep-stats.csv", header=T) %>% clean_names %>%
  dplyr::mutate_at(vars(tank, p_h, batch, date_extracted), as.factor)

sample.info <- read.csv("../data/RCK-exp-design.csv", header=T, na.strings = NA) %>%
          mutate_at(vars(Tank, Treatment, Treatment_Tank), as.factor) %>%
  left_join( ., library.stats, by=c("Sample"="tank_crab"))

save(sample.info, file="../data/sample.info")
```

## Import library stats from MultiQC and from library prep

```{r}
multiqc.stats <- read.delim(file="../results/fastqc/multiqc_data_trimmed-v2/multiqc_general_stats.txt", sep = "\t") 
colnames(multiqc.stats) <- gsub("FastQC_mqc.generalstats.fastqc.", "", colnames(multiqc.stats)) 
multiqc.stats <- multiqc.stats %>% 
  mutate(total_unique = total_sequences*(100-percent_duplicates)/100) %>%
  left_join(sample.info)
```

## Investigate possible correlations among # reads and prep stuff 

```{r}
cor(multiqc.stats %>% mutate(Tank=as.numeric(Tank)) %>% dplyr::select_if(is.numeric) %>% 
      dplyr::select(-Crab, -crab, -initial_volume, -volume_used_at_start_of_library_prep, -water_to_add_to_bring_to_50u_l, 
                    -diluted_concentration, -pcr_cycles, -volume_used_in_qc), use="complete.obs") %>% corrplot::corrplot(tl.cex=.75)
```

### Import counts matrix file as dataframe, extract sample # from file/column names to simplify them 
NOTE: featurecounts_redking_gene-v3 is the counts table that I will use. It does include singletons but does not include chimeras

```{r}
counts <- data.frame(read.table("../results/featureCounts/featurecounts_redking_gene-v3", header = T, stringsAsFactors = F, fill = FALSE))
counts <- counts %>%  column_to_rownames(var="Geneid")
counts <- counts %>% rename_all(~as.character(str_sub(colnames(counts)) %>%
                             gsub("X.scratch.lspencer.2022.redking.OA.aligned.bowtie.sorted.deduped.", "", .) %>%
                             gsub(".sorted.bam", "", .)))

# FOR v6 ONLY: (DIFFERENT FILE NAMES)
# counts <- data.frame(read.table("../results/featureCounts/featurecounts_redking_gene-v6", header = T, stringsAsFactors = F, fill = FALSE))
# counts <- counts %>%  column_to_rownames(var="Geneid")
# counts <- counts %>% rename_all(~as.character(str_sub(colnames(counts)) %>%
#                              gsub("X.scratch.lspencer.2022.redking.OA.aligned.bowtie2.sorted.", "", .) %>%
#                              gsub(".sorted.bam", "", .)))
# 
# save(counts, file = "../results/gene-counts-v2") #save R object with all gene counts

```

### Summarize counts and visualize (remove last column - that's undetermined counts)

```{r}
print(paste("Number of samples:", ncol(counts %>% select(contains("Tank"))), sep=" "))
print(paste("Total number of genes in dataframe:", prettyNum(nrow(counts), big.mark = ","), sep=" "))
print(paste("Average number of genes per sample:", prettyNum(mean(colSums(counts %>% select(contains("Tank")) != 0)), big.mark = ","), sep=" "))
print(paste("Total counts, all samples:", prettyNum(sum(colSums(counts %>% select(contains("Tank")))), big.mark = ","), sep=" "))
#print(paste("Counts for", colnames(counts %>% select(contains("Tank"))), ":",  prettyNum(colSums(counts %>% select(contains("Tank"))), big.mark = ","), sep=" "))


#inspect total counts by sample
 ggplotly(
   ggplot(data.frame(colSums(counts %>% select(contains("Tank")))) %>% 
            dplyr::rename(count.total = 1) %>% rownames_to_column(var="sample")) + 
     geom_bar(aes(x=sample, y=count.total), stat = "identity") + ggtitle("Total count by sample") + 
              theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())) 
```


## OPTIONAL: FILTER WHOLE SAMPLES. 

## DECISION FEBRUARY 9TH, 2022: Removing sample "Tank_7_Crab_4", which is an outlier in the PCAs and heat maps 
Remove whole samples from the data set and sample info here if needed

```{r}
# remove.list <- c("Tank_7_Crab_4")
# counts <- counts[ , -which(names(counts) %in% remove.list)]
# sample.info <- sample.info[ -which(sample.info$Sample %in% remove.list), ]
# 
# # resave sample info object
# save(sample.info, file="../data/sample.info")
# 
# nrow(sample.info) == ncol(counts)-5 #should = TRUE
```

## OPTIONAL: FILTER WHOLE SCAFFOLDS 

This code provides the option to remove data that mapped to scaffolds 105+. This is possibly beneficial because I don't know whether or not those scaffolds are also included within scaffolds 1-104 (i.e. the chromosomes). 

NOTE:  For exploration purposes I will NOT remove them, and will see if expressed data mapping to scaffolds 105+ have the exact same genes/counts as on chromosomes. 

After preliminary examination of blast results (by looking at genes, lengths, and counts) it's difficult to tell whether the scaffolds 105+ are subsets of the chromosomes 1-104. For now I will retain scaffolds 105+. 


```{r}
# counts <- counts %>% separate(Chr, into = c("X", "Y", "scaffold"), sep = "_", remove = F) %>%
#   mutate(scaffold=as.integer(scaffold)) %>% filter(scaffold<=104) %>% dplyr::select(-X, -Y, -scaffold)
```

## Optional: FILTER GENES THAT ARE OUTLIERS IN OUTLIER SAMPLE (TANK_7_CRAB_4)  

## DECISION FEBRUARY 9TH, 2022: DO NOT REMOVE INDIVIDUAL GENES, INSTEAD REMOVE OUTLIER SAMPLE (ABOVE)

The sample Tank 7 Crab 4 is weird, and has outlier counts in many genes. I identified them in my Outlier notebook, so here I will remove them from the count matrix. 

NOTE: you cannot simply replace counts for some samples with NA. DESeq2 doesn't accept those. 

```{r}
# counts <- counts[-which(rownames(counts) %in% outliers),]
```

### Remove extraneous gene info, then transpose dataframe so each row = a sample (aka "objects"), and each column = genes (aka "variables") 
```{r}
#str(counts) #columns #1-#5 contain extraneous gene info (chr, start, end, strand, length). 
counts.t <- as.data.frame(t(counts[,-1:-5])) #remove extraneous columns, transform data to have each sample a row, each column a gene 
```

## Optional 

### Pre-filtering - remove low-frequency genes 

NOTE: Should i do this? DESeq2 throws out low-frequency genes anyway, BUT other folks do pre-filter. For example in https://doi.org/10.1186/s12864-017-4392-0 "Genes with mean count less than ten across all samples were removed."

```{r}
#keep <- colSums(counts.t, na.rm=TRUE) >= 10 #use sum
#keep <- colMeans(counts.t, na.rm=TRUE) >= 10 #use mean
keep <- rowSums( counts >= 10 ) >= 0.1*43 #keep genes with counts>=10 across at minimum 10% of the samples
counts.ts <- counts.t[,keep]
# counts.ts <- counts.t

print(paste("# genes remaining after pre-filtering:", ncol(counts.ts)))
print(paste("# of genes dropped:", ncol(counts.t) - ncol(counts.ts), sep=" "))
```

### Save counts file, and transformed counts file 
```{r}
save(counts, file = "../results/gene-counts")
save(counts.t, file = "../results/gene-counts-trans")
save(counts.ts, file = "../results/gene-counts-trans-filtered")
```

## Import Blue king crab Best Blast results 

Description of columns: 
```
 ID                 Sequence ID from the reference
 BlastType     BestBlast Hit, basically did the hit originate from the nr (X) or nt (N) database
 SeqLength   Length of the sequence being blasted  
 HitAcc          Accession number of the hit
 HitDesc        Description of the hit
 Score           Score of the alignment between the query and hit
 E.Value        E-Value of the alignment between the query and hit
 PercentIdent  The percent identity of the alignment (how well did they match)
 QueryStart    The base pair point were the alignment starts for the query
 QueryEnd      The base pair point were the alignment ends for the query
 HitStart       The base pair point were the alignment starts for the hit
 HitEnd        The base pair point were the alignment ends for the hit
```

I believe the accession numbers are the GenBank Accessions. 
Mutate "id" slightly - the gene IDs have different strings in the blast results (contains the string "model") and the counts file (contains the string "TU").
Mutate "pecent_ident" to create new column with numeric proportion

```{r}
P.plat.bestblast <- read_delim(file = "../references/bestblast.bkc_ref.tab", delim = "\t") %>% clean_names() %>% 
  mutate(id=gsub("model", "TU", id)) %>%
  separate(percent_ident, sep=" ", into=c("ratio", "percent_ident.num"), remove = F) %>% 
  mutate(percent_ident.num=gsub("\\(", "", percent_ident.num)) %>% mutate(percent_ident.num=gsub("\\%)", "", percent_ident.num)) %>% 
  mutate(percent_ident.num=as.numeric(percent_ident.num)/100) %>%
  mutate_at(vars(blast_type), as.factor) %>%
  select(-ratio)

# How many genes have hits with various e-values? 
paste("Total number of genes = ", P.plat.bestblast %>% nrow())
paste("Proportion of annotated genes with e-value < 1e-20 = ", (P.plat.bestblast %>% filter(e_value<1e-20) %>% nrow())/(P.plat.bestblast %>% nrow()))
paste("Proportion of annotated genes with e-value < 1e-10 = ", (P.plat.bestblast %>% filter(e_value<1e-10) %>% nrow())/(P.plat.bestblast %>% nrow()))
paste("Proportion of annotated genes with e-value < 1e-5 = ", (P.plat.bestblast %>% filter(e_value<1e-5) %>% nrow())/(P.plat.bestblast %>% nrow()))
```
## Annotate gene counts dataframe 

```{r}
counts.annot <- right_join(P.plat.bestblast %>% select(id, blast_type, hit_acc, hit_desc, e_value, percent_ident.num),
                           counts %>% rownames_to_column(var = "id"), "id")
write.csv(counts.annot, file = "../results/counts.annotated.csv", row.names = F, quote = F)
```


## Annotate some genes with Uniprot IDs and Gene Ontology info 

The below gene annotations were generated by Laura Spencer using blast with the Uniprot/Swissprot database. It is no longer needed, as Giles provided annotations using his Best Blast protocol

## Import Uniprot/Swissprot annotated blue king crab genes 

blastx output format 6 is tab file with the following columns: 
1. qaccver = Query accesion.version
2. saccver = Subject accession.version
3. pident = Percentage of identical matches
4. length = Alignment length
5. mismatch = Number of mismatches
6. gapopen = Number of gap openings
7. qstart = Start of alignment in query
8. qend = End of alignment in query
9. sstart =  Start of alignment in subject
10. send = End of alignment in subject
11. evalue =  Expect value
12. bitscore = Bit score

## NOTE:  I needed GO IDs and gene functions, which weren't included in the blast file.  So I opened the P.platypus.gene_blastx_split.tab file in Excel, copied the column containing all Uniprot IDs, then pasted those into the tool Uniprot batch retrieval tool (https://www.uniprot.org/uploadlists/), and selected the columns: Entry, Entry name, Reviewed(?), Protein names, Gene names, Organism, Gene ontology (biological process), Gene ontology (GO), Gene ontology Ids. I then downloaded all entries to a tab file, saved as: /references/P.platypus_genes_GO.tab. Now I'll read that into R and join with the P.plat.blast dataframe to link GO IDs with genes for exploration and enrichment analyses. 

```{r}
P.plat.blast <- read_delim(file = "../references/P.platypus.gene_blastx.tab", delim = "\t", col_names = c("qaccver", "saccver", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore")) %>%
  separate(qaccver, sep = ":", into = c("geneID","na","Chr", "range")) %>%
  separate(range, sep="-", into=c("Start", "End")) %>% select(-na) %>%
  mutate_at(vars(Start, End), as.numeric) %>%
  separate(saccver, sep="\\|", into=c("na", "SPID", "gene.Uni"), remove = F) %>%
  select(-na) %>% separate(gene.Uni, sep="_", into=c("gene.Uni", "species"), remove=T) %>%
  group_by(geneID, Chr, Start, End) %>% slice(which.min(evalue))   # where multiple blast hits for same gene, select one with minimum e-value

write.table(P.plat.blast, file = "../references/P.platypus.gene_blastx_split.tab",quote = F, sep = "\t")

P.plat.blast.GO <- left_join(P.plat.blast, read_delim(file = "../references/P.platypus_genes_GO.tab", delim = "\t"),
                             by = c("SPID"="Entry")) %>% ungroup()
```
## 
## Save DEG lists identified using Bowtie2 aligned data 

```{r}
res.pco2.Bowtie <- res.pco2.AM # save list of all genes in DESeq2 analysis regardless of p-value
res.pco2.AM.Bowtie <- subset(res.pco2.AM, padj < 0.05)
res.pco2.AL.Bowtie <- subset(res.pco2.AL, padj < 0.05)
res.pco2.ML.Bowtie <- subset(res.pco2.ML, padj < 0.05)
```

