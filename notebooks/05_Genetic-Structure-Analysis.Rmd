---
title: "Genetic Structure Analysis"
author: "Laura H Spencer"
date: "3/24/2022"
output: html_document
---
```{r, message=FALSE, warning=FALSE, results=FALSE}
# for OutFLANK software

### Install required package devtools if not installed
if (!("devtools" %in% installed.packages())){install.packages("devtools")}
library(devtools)

### Install required package qvalue if not installed
if (!("qvalue" %in% installed.packages())){
  source("http://bioconductor.org/biocLite.R")
  biocLite("qvalue")
  }

### Install OutFLANK from github if not installed
if (!("OutFLANK" %in% installed.packages())){install_github("whitlock/OutFLANK")}

# Add all required libraries that are installed with install.packages() here
list.of.packages <- c("tidyverse", "reshape2", "plotly", "vcfR", "network", "janitor", "corrplot", "PerformanceAnalytics", "ggpubr", "RColorBrewer", "usedist", "vegan", "forcats", "valr", "pcadapt", "OutFLANK")

# Add all libraries that are installed using BiocManager here
bioconductor.packages <- c("SNPRelate", "DESeq2", "rtracklayer", "qvalue", "SeqArray", "qvalue")

# Install BiocManager if needed
if(!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
new.bioc.packages <- bioconductor.packages[!(bioconductor.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
if(length(new.bioc.packages)) BiocManager::install(new.bioc.packages)

# Load all required libraries
all.packages <- c(list.of.packages, bioconductor.packages)
lapply(all.packages, FUN = function(X) {
  do.call("require", list(X))
})

source("../references/biostats.R")
```

## Load sample info and gene annotation files

```{r}
sample.info <- read.csv("../data/RCK-exp-design.csv", header=T, na.strings = NA)

#load(file = "../references/P.plat.bestblast")
load(file = "../references/P.camt.blast")
load(file = "../references/P.camt.blast.GO")

genes <- read_delim(file = "../references/Paralithodes.camtschaticus_genes.bed", delim = "\t", col_names = c("chrom", "start", "end", "geneID"))
```

### Must close genofile if it's already open before running 

```{r}
snpgdsClose(genofile)
```


## Use SNPRelate to filter vcf files. Remove: 
- Select biallelic loci only 
- Loci with minor allele frequency < 5%
- Select loci that are present across all samples (missing.rate=0) 

```{r}
#vcf.fn <- "../results/genotype/rkc_rnaseq_genotypes-filtered-true.vcf.gz"  # SNP file from the Blue king crab aligned data aligned with Bowtie2
#vcf.fn <- "../results/star/rkc_rnaseq_genotypes-filtered-true.vcf.gz"  # SNP file from the Blue king crab aligned data aligned with STAR

vcf.fn <- "../results/genotype/rkc-genome/rkc_rnaseq_genotypes-filtered-true.vcf.gz"  # SNPs aligned with bowtie2 to concatenated Red king crab genome
SNPRelate::snpgdsVCF2GDS(vcf.fn, "../results/genotype/genotypes.gds", method="biallelic.only")
snpgdsSummary("../results/genotype/genotypes.gds")
```

## Open gds and check out genofile contents 

```{r}
(genofile <- snpgdsOpen("../results/genotype/genotypes.gds"))
```
## Prune/Clean SNPs 
- Remove those in linkage-disequilibrium
- Remove those with Minor Allele Frequency <5%
- Remove those that are missing from 20% or more of samples  

```{r}
snpset <- snpgdsLDpruning(genofile, maf=.05, missing.rate=0.15, autosome.only=FALSE, 
                          sample.id = sample.info[sample.info$Sample!="Tank_10_Crab_2",]$Sample) #<--- here I remove one sample, it has lots of missing data
                          #sample.id = sample.info$Sample) #<--- here I don't remove any samples
#snpset.id <- unlist(unname(snpset))
snpset.id <- unlist(snpset)
```

# `length(snpset.id)` SNPs remain after all filtering steps 

## IMPORTNAT NOTE: 
Since my .vcf doesn't include unique SNP IDs, they are assigned unique integers ids by SNPRelate, where 1=first row in .vcf 

### Extract data from the gds file to identify snp locations

```{r}
# take out integer-assigned snp id 
snp.id <- read.gdsn(index.gdsn(genofile, "snp.id"))

# # take out unique snp id from original VCF 
# snp.id.rs <- read.gdsn(index.gdsn(genofile, "snp.rs.id")) #<-- no unique snp id in original VCF file

# take out snp chromosome
chrom <- read.gdsn(index.gdsn(genofile, "snp.chromosome"))

# take out snp position on chromosome
pos <- read.gdsn(index.gdsn(genofile, "snp.position"))

# take out snp allele
allele <- read.gdsn(index.gdsn(genofile, "snp.allele"))

# Combine data into dataframe
genofile.data <- (cbind(snp.id, chrom, pos, allele)) %>% as.data.frame()
head(genofile.data)

# Filter for snps retained by SNPRelate after filtering and pruning and annotate
# Also add "start" and "end" columns for use with bed_intersect

genofile.snpset.data <- genofile.data %>% filter(snp.id %in% snpset.id) %>% 
  mutate(pos=as.numeric(pos)) %>% mutate(start=pos-1, end=pos+1)

#annotate genes containing SNPs 
(genofile.snpset.annot <- bed_intersect(x=genes, y=genofile.snpset.data, 
                                        suffix = c(".gene", ".snp")) %>% 
  left_join(P.plat.bestblast %>% dplyr::select(id_gtf, hit_acc, hit_desc, e_value), by = c("geneID.gene"="id_gtf")) %>%
    left_join(P.camt.blast %>% dplyr::select(geneID, SPID, evalue), by=c("geneID.gene"="geneID")) %>%
    left_join(P.camt.blast.GO %>% dplyr::select(gene_id, protein_names, gene_ontology_biological_process), by=c("geneID.gene"="gene_id"))) 

save(genofile.snpset.annot, file="../results/genotype/genofile.snpset.annot")
```

## PCA  

```{r}
# PCA using SNPRelate 
pca <- snpgdsPCA(genofile, num.thread=2, autosome.only=FALSE, verbose = TRUE, 
                 need.genmat = TRUE, snp.id =snpset.id, 
                 sample.id = sample.info[sample.info$Sample!="Tank_10_Crab_2",]$Sample )
                 #sample.id = sample.info$Sample )
pc.percent <- pca$varprop*100
head(round(pc.percent, 2)) #This is the proportion variance explained by each PC 
tab <- data.frame(sample.id = pca$sample.id,
    PC1.gen = pca$eigenvect[,1],    # the first eigenvector
    PC2.gen = pca$eigenvect[,2],    # the second eigenvector
    PC3.gen = pca$eigenvect[,3],    # the third eigenvector
    PC4.gen = pca$eigenvect[,4],    # the fourth eigenvector
    PC5.gen = pca$eigenvect[,5],    # the fifth eigenvector
    stringsAsFactors = FALSE)

# PCA using prcomp etc., but NOTE that I pull the covariance matrix from the SNPRelate PCA command  
pca.princomp.gen <- princomp(covmat=pca$genmat, scores=T, cor = F) #specify "covmat" because input is a covariance matrix (not raw data!)
summary(pca.princomp.gen)
pca.eigenval(pca.princomp.gen)[2,1:5] #The Proporation of Variance (aka %variance)  
screeplot(pca.princomp.gen, bstick=TRUE) #PC axes aren't super sign. - just look at PC1 

tab <- data.frame(sample.id = pca$sample.id,
    PC1.gen = pca.princomp.gen$loadings[,1],    # the first eigenvector
    PC2.gen = pca.princomp.gen$loadings[,2],    # the second eigenvector
    PC3.gen = pca.princomp.gen$loadings[,3],    # the third eigenvector
    PC4.gen = pca.princomp.gen$loadings[,4],    # the fourth eigenvector
    PC5.gen = pca.princomp.gen$loadings[,5],    # the fourth eigenvector
    stringsAsFactors = FALSE)

shapiro.test(pca.princomp.gen$loadings) #Multivariate normality assumption not met

tab.annot.gen <- left_join(tab, sample.info, by=c("sample.id"="Sample")) %>% droplevels() %>%
  mutate(Treatment=as.factor(Treatment))
group <- as.factor(tab.annot.gen$Treatment)
```

## Per-sample missing rate for retained SNPs 

```{r}
RV <- snpgdsSampMissRate(genofile, snp.id = snpset.id, 
                         sample.id = sample.info[sample.info$Sample!="Tank_10_Crab_2",]$Sample)
                         #sample.id = sample.info$Sample)
names(RV) <- pca$sample.id

barplot(RV, las = 2, cex.names = .5, col = c("#2c7bb6", "#d7191c", "#fdae61")[group])
title(ylab = "Sample Missingness (%)")
legend("top", legend=levels(group), col=c("#2c7bb6", "#d7191c", "#fdae61"), pch=19, ncol=3, cex=0.6, pt.cex=1)

# Add missingness rate to annotated PCA results file
tab.annot.gen$missingness <- RV

tab.annot.gen %>% mutate(Treatment=factor(Treatment, levels=c("Ambient", "Moderate", "Low"))) %>%
  ggplot(aes(x=Treatment, y=missingness, fill=Treatment)) + geom_violin(alpha=0.75) + 
  geom_jitter(col="black", width = 0.15) +
  theme_minimal() +
  stat_summary(fun.y=mean, geom="point", shape=8, size=4, color="black", fill="black") + 
    scale_fill_manual(values=c(Ambient="#2c7bb6", 
                               Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  ggtitle(paste("% Missing Rate for retained SNPs, by pH Treatment ", 
                "(No. loci = ", length(snpset.id), ")", sep="")) +
    geom_text(data=tab.annot.gen %>% group_by(Treatment) %>% 
                summarize(mean=mean(missingness)), 
              aes(x=Treatment, y=c(0.45, 0.31, 0.39), label=round(mean, 2)))

# There's a lot more missing SNP data from the ambient groups
```

## Examine first 5 PC axes 

```{r}
# PC1 X PC2
(a <- ggplot(tab.annot.gen, aes(x=PC2.gen, y=PC1.gen, size=missingness)) +
  geom_point(aes(col=Treatment), alpha=0.75) + # 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC2") + 
  xlab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  ylab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3))

# PC1 X PC3
(b <- ggplot(tab.annot.gen, aes(x=PC3.gen, y=PC1.gen, size=missingness)) + 
  geom_point(aes(col=Treatment), alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC3") + 
  xlab(paste("PC3 (", round(pc.percent[3], digits = 2), "%)", sep="")) + 
  ylab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3))

# PC1 X PC4
(c <- ggplot(tab.annot.gen, aes(x=PC4.gen, y=PC1.gen, size=missingness)) + 
  geom_point(aes(col=Treatment), alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC4") + 
  xlab(paste("PC4 (", round(pc.percent[4], digits = 2), "%)", sep="")) + 
  ylab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3))

# PC1 X PC5
(d <- ggplot(tab.annot.gen, aes(x=PC5.gen, y=PC1.gen, size=missingness)) + 
  geom_point(aes(col=Treatment), alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC4") + 
  xlab(paste("PC5 (", round(pc.percent[5], digits = 2), "%)", sep="")) + 
  ylab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3))

# PC2 X PC3
ggplot(tab.annot.gen, aes(x=PC2.gen, y=PC3.gen, size=missingness)) + 
  geom_point(aes(col=Treatment), alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC2xPC3") + 
  xlab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  ylab(paste("PC3 (", round(pc.percent[3], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC1 X PC2 color coded by tank 
ggplot(tab.annot.gen, aes(x=PC1.gen, y=PC2.gen, size=missingness)) + 
  geom_point(aes(col=as.factor(Tank)), alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC2 (showing tank no.)") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5)))

save(tab.annot.gen, file="../results/genotype/tab.annot.gen")


# GGSCATTER with ellipses and stars -
ggscatter(tab.annot.gen, x="PC1.gen", y="PC2.gen",
          col="Treatment", size=2.5, alpha=0.85, ellipse = TRUE, star.plot = TRUE, 
           palette = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  theme_minimal() + ggtitle("Global gene expression, PC1xPC2") + 
  # xlab(paste("PC1 (", round(pc.percent[1], digits = 1), "%)", sep="")) + 
  # ylab(paste("PC2 (", round(pc.percent[4], digits = 1), "%)", sep="")) + 
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5, linetype="blank"))) 

ggscatter(tab.annot.gen, x="PC3.gen", y="PC1.gen",
          col="Treatment", size=2.5, alpha=0.85, ellipse = TRUE, star.plot = TRUE, 
           palette = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  theme_minimal() + ggtitle("Global gene expression, PC1xPC2") + 
  # xlab(paste("PC1 (", round(pc.percent[1], digits = 1), "%)", sep="")) + 
  # ylab(paste("PC2 (", round(pc.percent[4], digits = 1), "%)", sep="")) + 
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5, linetype="blank"))) 

ggscatter(tab.annot.gen, x="PC4.gen", y="PC1.gen",
          col="Treatment", size=2.5, alpha=0.85, ellipse = TRUE, star.plot = TRUE, 
           palette = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  theme_minimal() + ggtitle("Global gene expression, PC1xPC4") + 
  # xlab(paste("PC1 (", round(pc.percent[1], digits = 1), "%)", sep="")) + 
  # ylab(paste("PC2 (", round(pc.percent[4], digits = 1), "%)", sep="")) + 
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5, linetype="blank"))) 

ggscatter(tab.annot.gen, x="PC3.gen", y="PC2.gen",
          col="Treatment", size=2.5, alpha=0.85, ellipse = TRUE, star.plot = TRUE, 
           palette = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  theme_minimal() + ggtitle("Global gene expression, PC3xPC2") + 
  # xlab(paste("PC1 (", round(pc.percent[1], digits = 1), "%)", sep="")) + 
  # ylab(paste("PC2 (", round(pc.percent[4], digits = 1), "%)", sep="")) + 
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5, linetype="blank"))) 
```
```{r}
tab.annot.gen %>% pivot_longer(cols=contains(c("PC2.gen", "PC3.gen", "PC4.gen", "PC5.gen")), names_to = "PC.axis", values_to = "PC.loc") %>%
  mutate(PC.axis=factor(PC.axis,
                           levels=c("PC2.gen", "PC3.gen", "PC4.gen", "PC5.gen"),
                           labels=c(
    paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep=""),
    paste("PC3 (", round(pc.percent[3], digits = 2), "%)", sep=""),
    paste("PC4 (", round(pc.percent[4], digits = 2), "%)", sep=""),
    paste("PC5 (", round(pc.percent[5], digits = 2), "%)", sep="")))) %>%
  ggplot(aes(x=PC.loc, y=PC1.gen, size=missingness, col=Treatment)) +
  geom_point(alpha=0.75) + # 
  theme_minimal() + #ggtitle("Genetic Structure, PC1xPC2") + 
  xlab(NULL) + 
  ylab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  scale_size_continuous(range = c(1,4), name = "% of SNPs missing") + 
  guides(colour = guide_legend(order=1, override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3) + 
  facet_wrap(~PC.axis)

```
ADONIS or other multivariate method using SNP data? 

```{r}
#pairwise.adonis(vsd.t[,-1:-3], vsd.t$Treatment, perm = 1000)
```


```{r}
ggplot(tab.annot.gen %>% pivot_longer(cols=starts_with("PC"), names_to = "PC.axis", values_to = "PC.loc"), 
       aes(x=abs(PC.loc), y=missingness, col=Treatment)) + geom_point(alpha=0.75) +
  theme_minimal() + 
  ggtitle("Correlation between % of SNPs missing (x) and abs(PC scores) (y) for each sample\nQuestion: do samples with many missing SNPs congregate near 0?") + 
    theme(legend.position = "bottom") + stat_smooth(geom="smooth", method="lm", se=FALSE, size=0.5, aes(group=Treatment)) +
    scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_cor(method = "pearson", show.legend=FALSE, size=2.5) +
  facet_wrap(~PC.axis, scales = "free")
```


## Distribution of genetic covariance matrix 

```{r}
pca$genmat %>% hist(breaks=100, main="Histogram of genetic covariance\nfrom SNPRelate")
```
## Relatedness Analysis using SNPRelate 

ID1: the id of the first individual
ID2: the id of the second individual
k0: the probability of sharing ZERO alleles
k1: the probability of sharing ONE alleles
kinship: kinship coefficient

```{r}
ibd.mle <- snpgdsIBDMLE(genofile, snp.id=snpset.id, num.thread=2, autosome.only = F, sample.id = sample.info[sample.info$Sample!="Tank_10_Crab_2",]$Sample)

# Kinship metric
ibd.mle.coeff <- snpgdsIBDSelection(ibd.mle)
head(ibd.mle.coeff)
hist(ibd.mle.coeff$kinship, breaks = 100)

kinship <- ibd.mle.coeff %>% 
  left_join(sample.info %>% dplyr::select(Sample, Treatment), by=c("ID1"="Sample")) %>% 
  rename("Treatment1"="Treatment") %>%
  left_join(sample.info %>% dplyr::select(Sample, Treatment), by=c("ID2"="Sample")) %>% 
  rename("Treatment2"="Treatment") %>%
  mutate(contrast=case_when(
      Treatment1 == Treatment2 ~ "same",
      Treatment1 != Treatment2 ~ "different")) %>%
  mutate(contrast.pairwise=case_when(
      Treatment1 == "Ambient" & Treatment2 == "Ambient" ~ "Amb.Amb",
      Treatment2 == "Ambient" & Treatment1 == "Ambient" ~ "Amb.Amb",
      Treatment1 == "Moderate" & Treatment2 == "Moderate" ~ "Mod.Mod",
      Treatment2 == "Moderate" & Treatment1 == "Moderate" ~ "Mod.Mod",
      Treatment1 == "Low" & Treatment2 == "Low" ~ "Low.Low",
      Treatment2 == "Low" & Treatment1 == "Low" ~ "Low.Low",
      Treatment1 == "Ambient" & Treatment2 == "Moderate" ~ "Amb.Mod",
      Treatment2 == "Ambient" & Treatment1 == "Moderate" ~ "Amb.Mod",
      Treatment1 == "Ambient" & Treatment2 == "Low" ~ "Amb.Low",
      Treatment2 == "Ambient" & Treatment1 == "Low" ~ "Amb.Low",
      Treatment1 == "Moderate" & Treatment2 == "Low" ~ "Mod.Low",
      Treatment2 == "Moderate" & Treatment1 == "Low" ~ "Mod.Low")) %>% 
  mutate(contrast.pairwise=factor(contrast.pairwise, levels=c("Amb.Amb", "Mod.Mod", "Low.Low", "Amb.Mod", "Amb.Low", "Mod.Low")))

ggplot(kinship, aes(x=contrast.pairwise, y=kinship, fill=contrast.pairwise)) + 
  geom_violin() + 
  theme_minimal() + 
  ggtitle("Kindship coefficient by treatment contrast") +
  geom_text(data=kinship %>% group_by(contrast.pairwise) %>% 
                summarize(mean=mean(kinship)), 
              aes(x=contrast.pairwise, y=mean+.11, label=round(mean, 3)))

ggplot(kinship, aes(x=contrast, y=kinship, fill=contrast)) + 
  geom_violin() + 
  theme_minimal() + 
  ggtitle("Kindship coefficient for individuals from \ndifferent treatment or same treatment") +
  geom_text(data=kinship %>% group_by(contrast) %>% 
                summarize(mean=mean(kinship)), 
              aes(x=contrast, y=mean+.12, label=round(mean, 4)))
```


## cluster analysis 

Use SNPRelate to calculate the fraction of identity by state for each pair of samples

```{r}
# To perform cluster analysis on the matrix of genome-wide IBS pairwise distances, 
# and determine the groups by a permutation score. 
# Result= only 1 group (?)
ibs.hc <- snpgdsHCluster(snpgdsIBS(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE, sample.id = sample.info[sample.info$Sample!="Tank_10_Crab_2",]$Sample))
#ibs.hc <- snpgdsHCluster(snpgdsIBS(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE, sample.id = sample.info$Sample))
rv <- snpgdsCutTree(ibs.hc)
plot(rv$dendrogram, leaflab="none", main="HapMap Phase II")

# Determine groups of individuals by treatment information
rv2 <- snpgdsCutTree(ibs.hc, samp.group=tab.annot.gen$Treatment)
plot(rv2$dendrogram, leaflab="none", main="HapMap Phase II")
legend("bottom", legend=levels(group), col=1:nlevels(group), pch=19, ncol=3, cex=0.6, pt.cex=1)
```

## Allele frequencies 

```{r}
AF.ambient <- snpgdsSNPRateFreq(genofile, snp.id=snpset.id, sample.id=subset(tab.annot.gen, Treatment=="Ambient")$sample.id, with.id = TRUE)

#AF.moderate <- snpgdsSNPRateFreq(genofile, snp.id=snpset.id, sample.id=subset(tab.annot.gen, Treatment=="Moderate")$sample.id, with.id = TRUE)
AF.moderate <- snpgdsSNPRateFreq(genofile, snp.id=snpset.id, sample.id=subset(tab.annot.gen, Treatment=="Moderate" & sample.id!="Tank_10_Crab_2")$sample.id, with.id = TRUE)

AF.low <- snpgdsSNPRateFreq(genofile, snp.id=snpset.id, sample.id=subset(tab.annot.gen, Treatment=="Low")$sample.id, with.id = TRUE)

AFs <- rbind(
  do.call(cbind.data.frame, AF.ambient[c("snp.id", "AlleleFreq", "MinorFreq", "MissingRate")]) %>% 
    mutate(Treatment=as.factor("Ambient")), 
do.call(cbind.data.frame, AF.moderate[c("snp.id", "AlleleFreq", "MinorFreq", "MissingRate")]) %>% 
  mutate(Treatment=as.factor("Moderate")), 
do.call(cbind.data.frame, AF.low[c("snp.id", "AlleleFreq", "MinorFreq", "MissingRate")]) %>% 
  mutate(Treatment=as.factor("Low")))
```

## Major allele frequency distribution by treatment 

```{r}
ggplot(AFs, aes(x=Treatment, y=AlleleFreq, fill=Treatment)) + geom_violin(trim = F, alpha=0.5) + 
  theme_minimal() + 
  stat_summary(fun.y=mean, geom="point", shape=8, size=4, color="black", fill="black") + 
  xlab("pH exposure") + ylab("Allele Frequency") +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  ggtitle(paste("Major Allele Frequency by pH Treatment\n", 
                "(No. loci = ", length(snpset.id), ")", sep="")) +
    geom_text(data=AFs %>% group_by(Treatment) %>% 
                summarize(mean=mean(AlleleFreq)), 
              aes(x=Treatment, y=mean+.1, label=round(mean, 3)))
```

## Minor allele frequency distribution by treatment 

```{r}
ggplot(AFs, aes(x=Treatment, y=MinorFreq, fill=Treatment)) + 
  geom_violin(trim = F, alpha=0.5) + 
  theme_minimal() + 
  stat_summary(fun.y=mean, geom="point", shape=8, size=4, color="black", fill="black") + 
  xlab("pH exposure") + ylab("Allele Frequency") +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  ggtitle(paste("Minor Allele Frequency by pH Treatment\n", 
                "(No. loci = ", length(snpset.id), ")", sep="")) +
    geom_text(data=AFs %>% group_by(Treatment) %>% 
                summarize(mean=mean(MinorFreq)), 
              aes(x=Treatment, y=mean+.1, label=round(mean, 3)))
```

##  Fst Calculations 
### Note: snpgdsFst() returns 5 things:
  - sample IDs 
  - SNP ids (i.e. indices)
  - "Fst" = weighted Fst estimate 
  - "MeanFst" = average of Fst estimates across all SNPs 
  - "FstSNP" = A vector of Fst for each SNP 

```{r}

# Fst among all 3 treatments 
Fst <- snpgdsFst(genofile, snp.id=snpset.id, 
                        sample.id=tab.annot.gen$sample.id, 
                  population=tab.annot.gen$Treatment,
    method="W&C84", autosome.only=FALSE, with.id = TRUE)
paste("Weir and Cockerham mean Fst estimate, all treatments compared: ", round(Fst$MeanFst, 5))
hist(Fst$FstSNP, breaks = 75, main="Fst distribution", col="dodgerblue3")

Fst.AM <- snpgdsFst(genofile, snp.id=snpset.id, 
                        sample.id=subset(tab.annot.gen, Treatment %in% c("Ambient", "Moderate"))$sample.id, 
               population=droplevels(subset(tab.annot.gen, Treatment %in% c("Ambient", "Moderate"))$Treatment),
    method="W&C84", autosome.only=FALSE, with.id = TRUE)
paste("Weir and Cockerham mean Fst estimate, Ambient vs Moderate: ", round(Fst.AM$MeanFst, 5))
hist(Fst.AM$FstSNP, breaks = 75, main="Fst distribution", col="dodgerblue3")

Fst.AL <- snpgdsFst(genofile, snp.id=snpset.id, 
                        sample.id=subset(tab.annot.gen, Treatment %in% c("Ambient", "Low"))$sample.id, 
               population=droplevels(subset(tab.annot.gen, Treatment %in% c("Ambient", "Low"))$Treatment),
    method="W&C84", autosome.only=FALSE, with.id = TRUE)
paste("Weir and Cockerham mean Fst estimate, Ambient vs Low: ", round(Fst.AL$MeanFst, 5))
hist(Fst.AL$FstSNP, breaks = 75, main="Fst distribution", col="dodgerblue3")

Fst.ML <- snpgdsFst(genofile, snp.id=snpset.id, 
                        sample.id=subset(tab.annot.gen, Treatment %in% c("Moderate", "Low"))$sample.id, 
               population=droplevels(subset(tab.annot.gen, Treatment %in% c("Moderate", "Low"))$Treatment),
    method="W&C84", autosome.only=FALSE, with.id = TRUE)
paste("Weir and Cockerham mean Fst estimate, Moderate vs Low: ", round(Fst.ML$MeanFst, 5))
hist(Fst.ML$FstSNP, breaks = 75, main="Fst distribution", col="dodgerblue3")

Fsts <- rbind(
  
  do.call(cbind.data.frame, Fst[c("snp.id", "FstSNP")]) %>% mutate(contrast=as.factor("all")), 

  do.call(cbind.data.frame, Fst.AM[c("snp.id", "FstSNP")]) %>% mutate(contrast=as.factor("AvsM")),

  do.call(cbind.data.frame, Fst.AL[c("snp.id", "FstSNP")]) %>% mutate(contrast=as.factor("AvsL")),

  do.call(cbind.data.frame, Fst.ML[c("snp.id", "FstSNP")]) %>% mutate(contrast=as.factor("MvsL"))) 

ggplot(Fsts, aes(x=contrast, y=FstSNP, fill=contrast)) + geom_violin(trim = F) + 
  stat_summary(fun.y=mean, geom="point", shape=8, size=3.5, color="black", fill="black") +
  ggtitle(paste("SNP Fst, Adults by pCO2 treatment\n", "(No. loci = ", length(snpset.id), ")", sep="")) +
    geom_text(data=Fsts %>% group_by(contrast) %>% summarize(mean=mean(FstSNP)), aes(x=contrast, y=.65, label=round(mean, 3)))
```

## Identify SNPs with high Fst among populations, and use to re-generate PCAs 

```{r}
hist(Fsts$FstSNP, breaks = 100)

# Identify Fst outliers via boxplot 
out.min <- (boxplot(Fsts$FstSNP))$out %>% summary() %>% as.matrix() %>% t() %>% as.data.frame() %>% dplyr::select("Min.") %>% unlist()

Fsts %>% filter(FstSNP >=out.min) %>% dplyr::select(snp.id) %>% unique() %>% nrow() #42 loci that have outlying Fst values (>= 0.1680)

snps.fst <- Fsts %>% filter(FstSNP >=out.min) %>% dplyr::select(snp.id) %>% unique() %>% pull(snp.id)
```

### Here is a list of SNPs that have the highest Fst values (outliers in boxplot, Fst>`out.min`) and are located within genes

```{r}
genofile.snpset.annot %>% filter(snp.id.snp %in% snps.fst)
```
## Identity-by-state 

```{r}
# lbls <- paste("PC", 1:4, "\n", format(pc.percent[1:4], digits=2), "%", sep="")
# pairs(pca$eigenvect[,1:4], col=as.color(tab.annot.gen$Treatment), labels=lbls, main="Colors = pH Treatment")
# pairs(pca$eigenvect[,1:4], col=as.color(tab.annot.gen$Tank), labels=lbls, main="Colors = Tank")
```

## Multidimensional scaling analysis using Identity-By-State (IBS) proportion
```{r}
ibs <- snpgdsIBS(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE, 
                 sample.id = sample.info[sample.info$Sample!="Tank_10_Crab_2",]$Sample)
                 #sample.id = sample.info$Sample)
pop.idx <- order(tab.annot.gen$Treatment)

# par(xpd=TRUE)
# heatmap(ibs$ibs, col=terrain.colors(16), labCol=TRUE,
#        RowSideColors=c("black","red","green")[tab.annot.gen$Treatment])
# legend(0.22,-.15, legend=levels(tab.annot.gen$Treatment), pch="o", col=1:nlevels(tab.annot.gen$Treatment),
#       text.col=1:nlevels(tab.annot.gen$Treatment), cex=.75, ncol=4)

#Perform multidimensional scaling analysis on the matrix of genome-wide IBS pairwise distances:
loc <- cmdscale(1 - ibs$ibs, k = 2)
x <- loc[, 1]; y <- loc[, 2]

plot(x, y, col=group, xlab = "", ylab = "",
    main = "Multidimensional Scaling Analysis (IBS)", cex=1.2, pch=16)
#text(x, y+.01, labels=tab.annot.gen$sample.id, cex=0.6, font=2, col=as.integer(group))
legend("topright", legend=levels(group), pch="o", text.col=1:nlevels(group))

# Identify crab in each cluster and add to annotation file
tab.annot.gen <- tab.annot.gen %>% left_join(
  data.frame(x, y, sample=tab.annot.gen$sample.id) %>%
  mutate(ibs.cluster=case_when(
    x < -0.1 ~ "left",
    x > 0.1 ~"right",
    x < 0.05 & x > -0.1 & y < 0.1 ~ "middle")) %>% #,
    #y > 0.1 ~ "top"))
      dplyr::select(sample, ibs.cluster),
  by=c("sample.id"="sample"))
table(tab.annot.gen$ibs.cluster)
```

## Distribution of genetic covariance matrix 

```{r}
ibs$ibs %>% hist(breaks=100, main="Histogram of Identity-By-State proportion\nfrom SNPRelate")
```


```{r}
# Another look at relatedness estimate
# test <- snpgdsGRM(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE, method="GCTA")
# test$grm %>% hist(breaks=100, main="Histogram of genetic relationship matrix, method=GCTA\nfrom SNPRelate", prob=TRUE)
```


## Correlation analysis, Genetic PCAs ~ Expression PCAs 

### Generage PCAs from expression data for integration 

#### PCA with all genes using princomp and showing broken stick 

```{r}
load(file = "../results/deseq2/vsd.pH") #vsd.pH
pca.princomp.expr <- prcomp(t(assay(vsd.pH))) #scale=F for variance-covariance matrix
pca.eigenval(pca.princomp.expr) #The Proporation of Variance = %variance 
(pc.percent <- pca.eigenval(pca.princomp.expr)[2,1:4]*100)
screeplot(pca.princomp.expr, bstick=TRUE) #looks like PC 1-2 are significant, but also pull the 3rd 
tab.expr <- data.frame(sample.id = colnames(assay(vsd.pH)),
    PC1.expr = pca.princomp.expr$x[,1],    # the first eigenvector
    PC2.expr = pca.princomp.expr$x[,2],    # the second eigenvector
    PC3.expr = pca.princomp.expr$x[,3],    # the third eigenvector
    PC4.expr = pca.princomp.expr$x[,4],    # the fourth eigenvector
    stringsAsFactors = FALSE)
shapiro.test(pca.princomp.expr$x) #multivariate normality not met 
tab.expr.annot <- left_join(tab.expr, sample.info, by=c("sample.id"="Sample")) %>% droplevels()
group.expr <- as.factor(tab.expr.annot$Treatment)
```

```{r}
ggplot(tab.expr.annot, aes(x=PC1.expr, y=PC2.expr)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.85) + 
  theme_minimal() + ggtitle("Expression, all genes, PC1xPC2") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 1), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent[2], digits = 1), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(color=Treatment), size=0.3)

save(tab.expr.annot, file="../results/genotype/tab.expr.annot")

# # GGSCATTER with ellipses and stars 
# ggscatter(tab.expr.annot, x="PC1.expr", y="PC2.expr",
#           color="Treatment", size=3.5, alpha=0.85, 
#            palette = c("#2c7bb6","#fdae61", "#d7191c"),
#    ellipse = TRUE, star.plot = TRUE) + 
#   theme_minimal() + ggtitle("Expression, all genes, PC1xPC2") + 
#   xlab(paste("PC1 (", round(pc.percent[1], digits = 1), "%)", sep="")) + 
#   ylab(paste("PC2 (", round(pc.percent[2], digits = 1), "%)", sep="")) + 
#   theme(legend.position = "right") + 
#   guides(colour = guide_legend(override.aes = list(size=3.5))) 
```

## PCA with gene set that are DEGs among any pH comparison 

```{r}
# load in DEG lists 
load(file = "../results/deseq2/diffex.AM")
load(file = "../results/deseq2/diffex.AL")
load(file = "../results/deseq2/diffex.ML")

pca.princomp.expr.pH <-
  prcomp(cov(assay(vsd.pH[unique(c(rownames(diffex.AM),rownames(diffex.AL),rownames(diffex.ML))),])))

# pca.princomp.expr.pH <-
#   prcomp(t(assay(vsd.pH[unique(c(rownames(diffex.AM),rownames(diffex.AL),rownames(diffex.ML))),])),
#          center=T, scale=T)


pca.eigenval(pca.princomp.expr.pH) #The Proporation of Variance = %variance 
(pc.percent.pH <- pca.eigenval(pca.princomp.expr.pH)[2,1:4]*100)
screeplot(pca.princomp.expr.pH, bstick=TRUE) #looks like PC 1 & 2
tab.expr.pH <- data.frame(sample.id = colnames(assay(vsd.pH)),
    PC1.degs = pca.princomp.expr.pH$x[,1],    # the first eigenvector
    PC2.degs = pca.princomp.expr.pH$x[,2],    # the second eigenvector
    PC3.degs = pca.princomp.expr.pH$x[,3],    # the third eigenvector
    PC4.degs = pca.princomp.expr.pH$x[,4],    # the third eigenvector
    stringsAsFactors = FALSE)
tab.expr.pH.annot <- left_join(tab.expr.pH, sample.info, by=c("sample.id"="Sample")) %>% droplevels()
group.pH.expr <- as.factor(tab.expr.pH.annot$Treatment)
```

```{r}
ggplot(tab.expr.pH.annot, aes(x=PC1.degs, y=PC2.degs)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.85) + 
  theme_minimal() + ggtitle("Expression PC1xPC2, DEGs in response to pH") + 
  xlab(paste("PC1 (", round(pc.percent.pH[1], digits = 1), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent.pH[2], digits = 1), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(color=Treatment), size=0.3)
save(tab.expr.pH.annot, file="../results/genotype/tab.expr.pH.annot")
```

## Merge PC axes from genetic analyis, expression analysis using all data, and expression analysis using DEGs only  

```{r}
PCA.merged <- left_join(left_join(
  tab.annot.gen %>% dplyr::select(sample.id, Treatment, Tank, starts_with("PC")),
  tab.expr.annot %>% dplyr::select(starts_with("PC"),sample.id), by=c("sample.id")), 
  tab.expr.pH.annot %>% dplyr::select(starts_with("PC"),sample.id), by=c("sample.id"))
```

## Examine correlation among genetic and expression PC axes

```{r}
chart.Correlation(PCA.merged %>% dplyr::select(starts_with("PC")), histogram=F, pch=19, method = "pearson")
mtext("PC Axes Correlation, Genetic (.gen) ~ Expression (.all & .degs)", side=3, line=1.25)
```
```{r}
# Examine linear relationship between first two Expression PC axes and genetic PC axes, also testing for effect of & interaction with Treatment 

anova(lm(PC1.expr ~ PC1.gen*Treatment, data=PCA.merged))
summary(lm(PC1.expr ~ PC1.gen*Treatment, data=PCA.merged)) 
ggscatter(PCA.merged, x="PC1.gen", y="PC1.expr", 
          add="reg.line", conf.int = TRUE,
          color="Treatment", palette=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
    ggtitle("Genetic PC1 (8.9%) ~ Expression PC1 Axes") + 
  xlab("Genetic PC1") + ylab("Expr PC1") + 
  stat_cor(aes(color=Treatment), method = "pearson", show.legend=FALSE, label.y = c(-200, -175, -150)) +
  theme_pubclean() + theme(legend.position = "bottom") + 
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)

anova(lm(PC1.expr ~ PC2.gen*Treatment, data=PCA.merged)) 
summary(lm(PC1.expr ~ PC2.gen*Treatment, data=PCA.merged)) 
ggscatter(PCA.merged, x="PC2.gen", y="PC1.expr", 
          add="reg.line", conf.int = TRUE,
          color="Treatment", palette=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
    ggtitle("Genetic PC2 ~ Expression PC1 Axes") + 
  xlab("Genetic PC2") + ylab("Expr PC1") + 
  stat_cor(aes(color=Treatment), method = "pearson", show.legend=FALSE, label.y = c(-200, -175, -150)) +
  theme_pubclean() + theme(legend.position = "bottom") + 
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)


anova(lm(PC2.expr ~ PC1.gen*Treatment, data=PCA.merged)) 
summary(lm(PC2.expr ~ PC1.gen*Treatment, data=PCA.merged)) 
ggscatter(PCA.merged, x="PC1.gen", y="PC2.expr", 
          add="reg.line", conf.int = TRUE,
          color="Treatment", palette=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
    ggtitle("Genetic PC2 ~ Expression PC1 Axes") + 
  xlab("Genetic PC1") + ylab("Expr PC2") + 
  stat_cor(aes(color=Treatment), method = "pearson", show.legend=FALSE, label.y = c(-200, -175, -150)) +
  theme_pubclean() + theme(legend.position = "bottom") + 
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)

anova(lm(PC2.expr ~ PC2.gen*Treatment, data=PCA.merged)) 
summary(lm(PC2.expr ~ PC2.gen*Treatment, data=PCA.merged)) 
ggscatter(PCA.merged, x="PC2.gen", y="PC2.expr", 
          add="reg.line", conf.int = TRUE,
          color="Treatment", palette=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
    ggtitle("Genetic PC2 ~ Expression PC2 Axes") + 
  xlab("Genetic PC2") + ylab("Expr PC2") + 
  stat_cor(aes(color=Treatment), method = "pearson", show.legend=FALSE, label.y = c(-200, -175, -150)) +
  theme_pubclean() + theme(legend.position = "bottom") + 
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)

```

```{r}
# Examine linear relationship between first DEG Expression PC axis and genetic PC axes, also testing for effect of & interaction with Treatment 

anova(lm(PC1.degs ~ PC1.gen*Treatment, data=PCA.merged))
summary(lm(PC1.degs ~ PC1.gen*Treatment, data=PCA.merged)) 
ggscatter(PCA.merged, x="PC1.gen", y="PC1.degs", 
          add="reg.line", conf.int = TRUE,
          color="Treatment", 
          palette=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
    ggtitle("Genetic PC1 ~ DEGs PC1 Axes") + 
  xlab("Genetic PC1") + ylab("DEGs PC1") + 
  stat_cor(aes(color=Treatment), 
    method = "pearson", show.legend=FALSE, 
           #label.y = c(-200, -175, -150)
           ) +
  theme_pubclean() + theme(legend.position = "bottom") + 
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), 
    alpha=0.85, size=1.8)

anova(lm(PC1.degs ~ PC2.gen*Treatment, data=PCA.merged)) 
summary(lm(PC1.degs ~ PC2.gen*Treatment, data=PCA.merged)) 
ggscatter(PCA.merged, x="PC2.gen", y="PC1.degs", 
          add="reg.line", conf.int = TRUE,
          color="Treatment", palette=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
    ggtitle("Genetic PC2 ~ DEGs PC1 Axes") + 
  xlab("Genetic PC2") + ylab("DEGs PC1") + 
  stat_cor(aes(color=Treatment), method = "pearson", show.legend=FALSE, 
           #label.y = c(-200, -175, -150)
           ) +
  theme_pubclean() + theme(legend.position = "bottom") + 
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)
```


```{r}
# PCA.merged.4plots <- PCA.merged %>% dplyr::select(PC1.gen, PC2.gen, PC3.expr, PC4.degs) %>% 
#   pivot_longer(cols = c(PC3.expr, PC4.degs), values_to = "score", names_to = "PC.expr") %>% 
#   mutate(PC.expr=as.factor(PC.expr))

anova(lm(PC3.expr ~ PC2.gen*Treatment, data=PCA.merged))
summary(lm(PC3.expr ~ PC2.gen*Treatment, data=PCA.merged)) 
ggscatter(PCA.merged, x="PC2.gen", y="PC3.expr", 
          add="reg.line", conf.int = TRUE,
          color="Treatment", palette=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
    ggtitle("Genetic PC2 ~ Expression PC3 Axes") + 
  xlab("Genetic PC2") + ylab("Expr PC3") + 
  stat_cor(aes(color=Treatment), method = "pearson", show.legend=FALSE, label.y = c(-200, -175, -150)) +
  theme_pubclean() + theme(legend.position = "bottom") + 
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)


anova(lm(PC4.expr ~ PC3.gen*Treatment, data=PCA.merged))
summary(lm(PC4.expr ~ PC3.gen*Treatment, data=PCA.merged)) 
ggscatter(PCA.merged, x="PC3.gen", y="PC4.expr", 
          add="reg.line", conf.int = TRUE,
          color="Treatment", 
          palette=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
    ggtitle("Genetic PC2 ~ Expression PC3 Axes") + 
  xlab("Genetic PC3") + ylab("Expr PC4") + 
  stat_cor(aes(color=Treatment), method = "pearson", show.legend=FALSE, label.y = c(-200, -175, -150)) +
  theme_pubclean() + theme(legend.position = "bottom") + 
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)



```


## Correlation between pairwise genetic distances and expression distances 

Step 1: generate pairwise genetic distances between samples based on SNPs
Step 2: generate pairwise distance matrices from expression data using: 
  - All expressed genes
  - pH-DEGs
Step 3: Calculate Pearson & Spearman correlations between genetic and expression distances 

### Source of distance matrices: 
  - For **genetic pairwise distances** the SPRelate Identiy-By-State analysis produced an nxn matrix of genome-wide average IBS pairwise identities
  - For **expression pairwise distances**  DESeq2 is used to calculate  Euclidean distance between samples on the rlog-transformed count data. 

```{r}
# Genetic distance matrices 
snp.dists <- ibs$ibs %>% `colnames<-` (ibs$sample.id) %>% `rownames<-` (ibs$sample.id)

# Expression distance matrices, ALL expression data   
sampleDistss <- dist(t(assay(vsd.pH)))

# Expression distance matrix, pH DEGs 
sampleDistss.pH <- dist(t(assay(vsd.pH[rownames(vsd.pH) %in%
  unique(c(rownames(diffex.AM),rownames(diffex.AL),rownames(diffex.ML))),])))

# Create list of samples that are found in both the genetic and expression distance matrices 
dist.sampless <- c(as.matrix(sampleDistss) %>% rownames())[c(as.matrix(sampleDistss) %>% rownames()) %in% rownames(snp.dists)]

# Subset each distance matrix to only include samples found in both 
snp.dists.filt <- dist_subset(d=snp.dists, idx=dist.sampless) # genetic distance matrix, common samples
sampleDistss.filt  <- dist_subset(d=sampleDistss, idx=dist.sampless) # expression distance matrix, common samples
sampleDistss.pH.filt  <- dist_subset(d=sampleDistss.pH, idx=dist.sampless) # DEG distance matrix, common samples

# Check to see if matrices are in same order 
all(snp.dists.filt %>% as.matrix() %>% rownames() == sampleDistss.filt %>% as.matrix() %>% rownames()) # yes! 

# Perform correlation 
plot(x=snp.dists.filt, y=sampleDistss.filt, main="Correlation between pairwise distances\nSNP-based ~ Expr-based")
plot(x=snp.dists.filt, y=sampleDistss.pH.filt, main="Correlation between pairwise distances\nSNP-based ~ DEG-based")

packageVersion("SNPRelate")
```
```{r}
# Perform mantel test 
mantel(snp.dists.filt, sampleDistss.filt, permutations=9999 ) #distance matrices are not sign. correlated 
mantel(snp.dists.filt, sampleDistss.pH.filt, permutations=9999 ) #distance matrices are not sign. correlated 

distancess <- cbind(
  melt(as.matrix(sampleDistss.filt), varnames = c("row", "col"), value.name = "expr.all"),
melt(as.matrix(sampleDistss.pH.filt), varnames = c("row", "col"), value.name = "expr.pH")["expr.pH"],
melt(as.matrix(snp.dists.filt), varnames = c("row", "col"), value.name = "snp")["snp"])

# remove 0 distances and join with factors (population, pCO2 treatment)
distancess <- distancess %>% 
  dplyr::filter(snp!=0) %>% 
  left_join((sample.info %>% 
               dplyr::select(Sample, Treatment)), by=c("row"="Sample")) %>%
  mutate(Treatment=as.factor(Treatment))

# Inspect expression distance matrices vs. snp distance matrix for possible correlations? 
chart.Correlation(distancess[3:5] %>% filter(expr.all!=0),histogram=F, pch=19) #snp vs. expr & deg correlation are both weak but significant 

cor.test(distancess$snp, distancess$expr.all, method = "pearson") #cor -0.15
cor.test(distancess$snp, distancess$expr.pH, method = "pearson") #cor -0.08

ggscatter(distancess, x = "snp", y = "expr.all", size=1,
   add = "reg.line",  # Add regressin line
   add.params = list(color = "black", fill = "gray50"), # Customize reg. line
   conf.int = TRUE # Add confidence interval
   ) + stat_cor(method = "pearson", size=5, colour="red") +
  xlab("Genetic Distance") + ylab("Expression Distance") + 
  ggtitle("Sample-sample distances, SNPs ~ All genes") +
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5)))

ggscatter(distancess, x = "snp", y = "expr.pH", size=1,
   add = "reg.line",  # Add regressin line
   add.params = list(color = "black", fill = "gray50"), # Customize reg. line
   conf.int = TRUE # Add confidence interval
   ) + stat_cor(method = "pearson", size=5, colour="red") +
  xlab("Genetic Distance") + ylab("Expression Distance") + 
  ggtitle("Sample-sample distances, SNPs ~ DEGs only") +
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5)))
```

### More analysis via vcfR - compare allelic richness and heterozygosity by pH exposure

### First create a vcf of SNPs filtered for loci with max 20% missing rate, and remove loci with <5% minor allele frequency
I did this on Sedna using the slurm script [filter-vcf.sh])(../scripts/filter-vcf.sh), which executed the following code:

```
vcftools --gzvcf \
"/scratch/lspencer/2022-redking-OA/genotypes/rkc_rnaseq_genotypes-filtered-true.vcf.gz" \
--max-missing 0.80 --maf 0.05 --recode --recode-INFO-all --out \
"/scratch/lspencer/2022-redking-OA/genotypes/rkc_rnaseq_genotypes-final"
```
This created the file rkc_rnaseq_genotypes-final.recode.vcf  

I used [this tutorial](http://www.ddocent.com/filtering/) as an example. 
  - call vcftools
  - feed it a vcf file after the --vcf flag
  - Set --max-missing 0.90 to keep only loci with 10% missing genotypes across all individuals
  - The --recode flag tells the program to write a new vcf file with the filters
  - The --recode-INFO-all keeps all the INFO flags from the old vcf file in the new one. 
  - Lastly, --out designates the name of the output

```{r}
# Load the data
vcf <- read.vcfR("../results/genotype/rkc-genome/rkc_rnaseq_genotypes-final_miss15.recode.vcf", verbose = FALSE )

# Quantify missing data for each sample 
myMiss <- apply(extract.gt(vcf), MARGIN = 2, function(x){ sum(is.na(x)) })
myMiss <- myMiss/nrow(vcf)
par(mar = c(12,4,4,2))
barplot(myMiss, las = 2, cex.names = .5)
title(ylab = "Sample Missingness (%)")
```
```{r}
#extract.gt(vcf)
packageVersion("vcfR")
```


```{r}
# Confirm order of samples in vcf matches order of samples in the "sample.info" dataframe 
all(colnames(extract.gt(vcf)) == sample.info$Sample) # no, not in same order. Need to create a re-ordered sample.info object

sample.info.vcf <- sample.info %>% dplyr::slice(match(colnames(extract.gt(vcf)), Sample)) %>%
  mutate(Treatment=as.factor(Treatment))

# How many samples per pH treatment?
nsamples <- sample.info.vcf[match(colnames(extract.gt(vcf)), sample.info.vcf$Sample),] %>% group_by(Treatment) %>% tally()


# Calculate differentiation / diversity stats for each treatment
myDiff <- genetic_diff(vcf, pops = sample.info.vcf$Treatment, method = 'nei')
paste("No. SNPs included in this vcfR analysis ", nrow(myDiff), sep="")

# Summarize diversity indices (mean)
round(colMeans(myDiff[,-1:-2], na.rm = TRUE), digits = 3)
```

# Heterozygosity by pH Treatment

```{r}
dpf <- melt(myDiff[,c(3:5)], varnames=c('Index', 'Sample'), value.name = 'Depth', na.rm=TRUE) %>%
  mutate(Treatment=as.factor(substring(variable, 4))) %>%
  mutate(Treatment=factor(Treatment, levels=c("Ambient", "Moderate", "Low")))

ggplot(dpf, aes(x=Treatment, y=Depth)) + 
  geom_violin(aes(fill=Treatment), adjust = 1.2, alpha=0.75) + 
  xlab("") + ylab("") + theme_bw() +
    theme(axis.text.x = element_text(size=7, angle=50, hjust=1)) + 
  ggtitle(paste("Heterozygosity by pH Treatment \nNo. SNPs =", nrow(myDiff))) +
        stat_summary(fun.y=mean, geom="point", shape=15, size=3, color="black", fill="black") +
    geom_text(data=dpf %>% group_by(Treatment) %>% 
                summarize(mean=mean(Depth)), aes(x=Treatment, y=.45, label=round(mean, 3)), size=3) +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"))
```

# Allelic richness - could this be skewed by missing samples and data for SNPs

```{r}
dpf.n <- melt(myDiff[,c(7:9)], varnames=c('Index', 'Sample'), value.name = 'Depth', na.rm=TRUE) %>%
  mutate(Treatment=as.factor(substring(variable, 3)))

ggplot(dpf.n, aes(x=Treatment, y=Depth)) + 
  geom_violin(aes(fill=Treatment), adjust = 1.2, alpha=0.75) + 
  xlab("") + ylab("") + theme_bw() +
    theme(axis.text.x = element_text(size=7, angle=50, hjust=1)) + 
  ggtitle(paste("Allelic Richnes by pH Treatment \nNo. SNPs =", nrow(myDiff))) +
        stat_summary(fun.y=mean, geom="point", shape=15, size=3, color="black", fill="black") +
    geom_text(data=dpf %>% group_by(Treatment) %>% 
                summarize(mean=mean(Depth)), aes(x=Treatment, y=31, label=round(mean, 4)), size=3) +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"))

```

## Are there any SNPs located in genes that are differentially expressed? 

```{r}
# Use vcfR to generate a dataframe with snp location information. Also generates a ton of other info 
snps.map <- genetic_diff(vcf, pops = as.factor(sample.info.vcf$Treatment), method = 'nei') %>% 
  mutate(POS=as.numeric(POS)) %>% mutate(start=POS-1, end=POS+1) %>% rename("CHROM"="chrom")

snps.map %>% head()
```

### Annotate SNPs by looking for intersection among SNPs and genes - 736 (25% miss) SNPSs located within gene coding regions

```{r}
(snps.annot <- bed_intersect(x=genes, y=snps.map %>% select(chrom, POS, start, end), suffix = c(".gene", ".snp")) %>% 
   mutate(snp.id=paste(chrom, POS.snp, sep="_")) %>% 
  left_join(P.plat.bestblast, by = c("geneID.gene"="id_gtf"))) #annotate genes containing SNPs 
```

### 94 SNPs are located within genes that are differentially expressed among pH treatments 

```{r}
(snps.degs <- snps.annot %>% 
  filter(geneID.gene %in% 
           unique(c(rownames(diffex.AM), rownames(diffex.AL), rownames(diffex.ML)))))
```

### 192 SNPs are located within genes associated with pH according to WGCNA

```{r}
load("../results/wgcna/geneInfo")
load(file="../results/wgcna/modules")
load(file="../results/wgcna/modules.p")
load(file="../results/wgcna/modules.cor")

(snps.wgcna.pH <- snps.annot %>% 
  left_join(geneInfo %>% 
              select(id, moduleColor, 
                     #GS.pH, p.GS.pH, 
                     GS.H_exp, p.GS.H_exp, 
                     match(modules.cor,names(geneInfo)), 
                     match(modules.p,names(geneInfo))), by=c("geneID.gene"="id")) %>%
  #filter(p.GS.pH < 0.05)) 
  filter(p.GS.H_exp < 0.05)) 
```

### 369 SNPS are located within genes assigned to pH-associated modules from WGCNA

```{r}
(snps.wgcna.module <- snps.annot %>% 
  left_join(geneInfo %>% 
              select(id, moduleColor, 
                     #GS.pH, p.GS.pH, 
                     GS.H_exp, p.GS.H_exp, 
                     match(modules.cor,names(geneInfo)), 
                     match(modules.p,names(geneInfo))), by=c("geneID.gene"="id")) %>%
  filter(moduleColor %in% modules))
```

### 140 SNPS are located within genes assigned to pH-associated modules from WGCNA _and_ are correlated with pH 

```{r}
(snps.wgcna.ph.module <- snps.annot %>% 
  left_join(geneInfo %>% 
              select(id, moduleColor, 
                     #GS.pH, p.GS.pH, 
                     GS.H_exp, p.GS.H_exp, 
                     match(modules.cor,names(geneInfo)), 
                     match(modules.p,names(geneInfo))), by=c("geneID.gene"="id")) %>%
  filter(moduleColor %in% modules) %>% 
   #filter(p.GS.pH < 0.05))
   filter(p.GS.H_exp < 0.05))
```

# Identify siblings using Colony 

I will use Colony to identify siblings in my samples. The Colony software is only available via the command line for Mac users (it's typically used via GUI on Windows). To get the most current version of the program I actually had to email the developer. He send me a link to download it. I'm running Colony Version 2.0.6.6 (June 30, 2020), which is saved on my computer and in this project's repo (references/colony2.mac.20200904).

Prepare files for Colony sibship analysis
Colony identifies siblings, which I would like to do with my juveniles. Here I prepare files for Colony.

Mac suggested that I only keep SNPs with very high minor allele frequencies. Here I use SNPRelate to export SNPs with MAF >=20%, and keeping the missing rate <= 20%. 

## Sibship analysis via Colony 

```{r}
snpset.4Colony <- snpgdsLDpruning(genofile, maf=.05, missing.rate=.15, autosome.only=FALSE,
                                  sample.id = sample.info[sample.info$Sample!="Tank_10_Crab_2",]$Sample)
snpset.id.4Colony <- unlist(unname(snpset.4Colony))
snpgdsCreateGenoSet(src.fn="../results/genotype/genotypes.gds",
                    dest.fn="../results/genotype/colony/genotypes-4Colony.gds",
                    snp.id=snpset.id.4Colony, verbose = FALSE,
                    sample.id = sample.info[sample.info$Sample!="Tank_10_Crab_2",]$Sample)
```

## Recode genotypes for Colony 

- **SNPRelate codes alleles this way:** "There are four possible values stored in the variable genotype: 0, 1, 2 and 3. For bi-allelic SNP sites, 0 indicates two B alleles, 1 indicates one A allele and one B allele, 2 indicates two A alleles, and 3 is a missing genotype. (When you) take out genotype data with sample and SNP IDs, and four possible values are returned 0, 1, 2 and NA (3 is replaced by NA).  

- **Colony codes alleles this way:** "The first column gives the individual ID (a string containing a maximum of 20 letters and/or numbers, no other characters are allowed), the 2nd and 3rd columns give the alleles observed for the individual at the first locus, the 4th and 5th give the alleles observed for the individual at the 2nd locus ... An allele is identified by an integer, in the range of 1~999999999. If the locus is a dominant marker, then only one (instead of 2) column is required for the marker, and the value for the genotype should be either 1 (dominant phenotype, presence of a band) or 2 (recessive phenotype, absence of a band). Missing genotypes are indicated by 0 0 for a codominant marker and 0 for a dominant marker."  Also, there cannot be any NA values in the Colony genotype data. 

I wanted to use the R program `radiator` to create a Colony formatted genotype file. But after a TON of attempts I wasn't able to get my SNPRelate .gds data into radiator directly nor could I successfully import a .vcf file. 

So, here I manually re-code the genotype matrix. 

```{r}
# Extract genotype matrix 
geno.matrix4Colony <- snpgdsGetGeno(gdsobj="../results/genotype/colony/genotypes-4Colony.gds", with.id=TRUE)

paste("No. of SNPs for Colony sibship analysis: ", ncol(geno.matrix4Colony$genotype), sep="") 
paste("No. of samples for Colony sibship analysis: ", nrow(geno.matrix4Colony$genotype), sep="") 

# Replace SNPRelate numeric allele coding with character allele coding 
a <- geno.matrix4Colony$genotype %>% as_data_frame() %>% 
  mutate_all(funs(str_replace(., "0", "BB"))) %>%
  mutate_all(funs(str_replace(., "1", "AB"))) %>%
  mutate_all(funs(str_replace(., "2", "AA")))

# Duplicate each column. Now there's 2 columns per locus, both containing the same bi-allelic genotype info. 
b <- a[rep(names(a), rep(2, times=ncol(a)))] %>% clean_names()
ncol(b) == ncol(a)*2 #should be TRUE 

# For each locus, extract the first allele in column 1, and the second allele in column 2. 
c <- b  #duplicate dataframe 
odds <- seq(from = 1, to = ncol(c), by = 2)
evens <- seq(from = 2, to = ncol(c), by = 2)
odds.names <- colnames(b[odds])
evens.names <- colnames(b[evens])

for (i in 1:length(odds)) {
c[[odds.names[i]]] <- substring(b[[odds.names[i]]], first = 1, last = 1)  
}
for (i in 1:length(evens)) {
c[[evens.names[i]]] <- substring(b[[evens.names[i]]], first = 2, last = 2)  
}

# Now replace the character allele information with Colony's way of numeric coding. 
# There are 2 columns for each locus (e.g. v1 and v1_2), and only 3 options for each allele:
# 1= B allele 
# 2= A allele 
# 0= missing allele 
(geno.matrix4Colony.recode <- c %>% 
  mutate_all(funs(str_replace(., "B", "1"))) %>%
  mutate_all(funs(str_replace(., "A", "2"))) %>%
  mutate_if(is.character,as.numeric) %>%
  replace(is.na(.), 0))

# Save genotype matrix to file, while also adding a column with sample number 
write_delim(cbind(sampleID=paste("O", geno.matrix4Colony$sample.id, sep=""),
                  geno.matrix4Colony.recode),
            file="../results/genotype/colony/geno.matrix.tab", delim="   ", col_names=FALSE)
```

# Create Colony input file 

I created a text file that will be the input for Colony. I used Colony's example input file to do so. 

Here's a snapshot of the input file, truncating the genotype info (there are 53 samples, but here I only show 2)

```
'rkc_snps'  !Dataset name
'rkc_colony'  !Output file name
42         ! Number of offspring in the sample
333        ! Number of loci
100        ! Seed for random number generator
0          ! 0/1=Not updating/updating allele frequency
2          ! 2/1=Dioecious/Monoecious species
0          ! 0/1=No inbreeding/inbreeding
0          ! 0/1=Diploid species/HaploDiploid species
0  0       ! 0/1=Polygamy/Monogamy for males & females
0          ! 0/1=Clone inference =No/Yes
0          ! 0/1=Full sibship size scaling =No/Yes
0          ! 0,1,2,3=No,weak,medium,strong sibship size prior; mean paternal & meteral sibship size
0          ! 0/1=Unknown/Known population allele frequency
1         ! Number of runs
2         ! Length of run
0         ! 0/1=Monitor method by Iterate#/Time in second
100000    ! Monitor interval in Iterate# / in seconds
0         ! non-Windows version
1         ! Fulllikelihood
3         ! 1/2/3=low/medium/high Precision for Full likelihood

V@        !Marker names
0@        !Marker types, 0/1 = codominant/dominant
0.000@    !Allelic dropout rate
0.0001@   !false allele rate

OTank_10_Crab_1 1 1 2 1 2 2 2 2 2 2 2 2 1 1 0 0 2 2 1 1 2 2 2 2 2 1 1 1 2 2 2 2 2 1 2 2 1 1 2 2 2 1 2 2 1 1 1 1 2 1 2 1 2 2 1 1 2 2 2 2 2 2 1 1 2 2 1 1 2 2 0 0 2 2 2 2 2 1 2 2 1 1 0 0 1 1 1 1 2 1 1 1 1 1 1 1 2 2 2 2 0 0 2 2 1 1 1 1 2 2 1 1 2 2 2 2 2 1 2 2 0 0 1 1 2 1 1 1 1 1 2 2 1 1 2 2 1 1 1 1 0 0 2 2 2 1 2 2 2 1 1 1 0 0 2 2 2 1 2 1 2 1 2 1 2 2 2 2 2 2 2 1 2 1 2 2 2 2 2 1 1 1 2 1 1 1 2 2 0 0 2 2 2 2 1 1 2 2 2 1 2 2 2 2 2 1 1 1 1 1 0 0 1 1 2 1 2 2 2 2 0 0 0 0 1 1 2 1 0 0 2 1 2 1 1 1 2 1 1 1 0 0 2 2 2 1 2 2 2 2 0 0 2 2 2 1 1 1 1 1 1 1 2 2 0 0 0 0 2 2 2 2 1 1 2 2 2 1 2 2 2 2 1 1 2 2 0 0 2 1 2 2 1 1 1 1 1 1 2 1 2 1 0 0 2 2 2 1 1 1 1 1 2 2 2 2 1 1 1 1 0 0 2 2 2 2 1 1 2 2 2 2 1 1 2 2 2 2 0 0 1 1 2 2 2 2 1 1 1 1 2 1 0 0 0 0 1 1 1 1 2 2 2 2 2 2 2 2 2 2 1 1 2 1 2 1 2 1 2 1 2 2 1 1 2 1 2 2 0 0 2 1 2 1 1 1 2 2 2 1 2 1 2 2 2 2 2 2 1 1 0 0 2 1 2 2 2 2 2 2 2 2 1 1 1 1 2 2 1 1 1 1 2 1 1 1 1 1 1 1 2 2 2 1 2 2 2 1 2 1 2 2 2 2 1 1 1 1 2 1 2 1 2 2 2 2 2 2 2 2 2 2 1 1 2 2 2 2 2 1 1 1 2 1 2 2 1 1 2 1 0 0 2 2 2 1 2 2 2 2 2 2 2 2 0 0 1 1 2 2 2 2 1 1 2 1 2 2 2 1 2 2 1 1 2 1
OTank_10_Crab_2 0 0 2 2 0 0 0 0 2 2 1 1 0 0 1 1 2 2 0 0 1 1 0 0 2 2 1 1 2 2 0 0 2 2 1 1 0 0 0 0 1 1 2 2 1 1 0 0 2 1 0 0 0 0 0 0 2 2 2 1 2 2 2 1 1 1 1 1 2 2 0 0 1 1 2 2 0 0 2 2 0 0 0 0 1 1 0 0 1 1 2 2 1 1 1 1 1 1 0 0 2 2 2 2 1 1 0 0 0 0 1 1 0 0 2 2 0 0 2 2 1 1 2 2 0 0 0 0 1 1 1 1 2 2 1 1 1 1 2 2 1 1 0 0 2 2 0 0 0 0 2 1 2 2 0 0 2 2 1 1 0 0 2 2 2 2 1 1 1 1 2 2 1 1 0 0 2 2 2 2 0 0 1 1 2 2 2 2 0 0 0 0 0 0 2 2 0 0 0 0 2 2 2 2 1 1 2 2 2 2 2 2 0 0 1 1 1 1 0 0 0 0 2 2 0 0 2 2 0 0 0 0 1 1 2 2 2 2 2 2 2 2 1 1 2 2 0 0 0 0 1 1 1 1 0 0 2 2 0 0 0 0 2 2 2 2 2 2 1 1 1 1 1 1 2 2 2 2 2 2 2 2 0 0 0 0 2 2 0 0 2 2 0 0 1 1 0 0 2 2 2 2 0 0 0 0 0 0 2 2 1 1 0 0 0 0 0 0 0 0 2 2 0 0 1 1 2 2 2 2 2 2 0 0 1 1 2 2 1 1 0 0 1 1 2 2 1 1 2 2 1 1 2 2 2 1 2 2 0 0 2 2 1 1 0 0 2 2 2 2 0 0 0 0 1 1 0 0 0 0 2 2 2 2 0 0 1 1 2 2 0 0 0 0 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 2 2 2 1 2 2 0 0 1 1 1 1 0 0 2 2 2 2 2 2 0 0 0 0 0 0 2 2 2 2 2 1 2 2 1 1 0 0 0 0 1 1 2 1 2 2 2 2 2 2 0 0 2 2 2 2 1 1 2 2 0 0 0 0 2 2 2 2 0 0 2 2 2 2 1 1 2 2 0 0 2 2 2 2 2 2 2 2 2 2 0 0 1 1 0 0 2 2 1 1 0 0 2 2 2 2 2 2 2 2 0 0 0 0
```

# Run Colony analysis on samples 

Note: I have to be in the colony directory to run it, so I change my directory in the same code chunk prior to executing the ./colony2s.out script 

```{bash, eval = FALSE}
cd ../results/genotype/colony
./colony2s.out IFN:colony2_rkc.dat
```

## Colony finished! Here are some results: 

```{bash}
cat ../results/genotype/colony/rkc_colony.BestCluster
```

```{r}
colony.clusters <- read_table("../results/genotype/colony/rkc_colony.BestCluster", col_names=TRUE) %>% clean_names() %>% 
  mutate_all(funs(str_replace(., "\\*|#", ""))) %>%
  mutate(cluster_index=as.numeric(cluster_index), father_id=as.numeric(father_id), mother_id=as.numeric(mother_id), probability=as.numeric(probability)) %>%
  mutate(offspring_id=str_replace(offspring_id, "O", "")) %>% 
  as.data.frame() %>% left_join(sample.info, by = c("offspring_id"="Sample")) %>%
  mutate(Treatment=factor(Treatment, levels=c("Ambient", "Moderate", "Low"))) %>% 
  column_to_rownames("offspring_id") %>% 
  mutate(offspring_id=rownames(.))

save(colony.clusters, file = "../results/genotype/colony/best-cluster-adult")  

father.order <- as.character(c(1,2,5,17,18,19,22,24,27,4,28,20,21,25,29,8,13,6,9,10,11,12,14,15,16,26,3,7,23))
mother.order <- as.character(c(20,21,23,25,26,27,30,4,6,24,29,2,3,5,17,19,22,1,18,8,7,9,10,11,12,13,14,15,28,16))

ggplot(colony.clusters, aes(x = father_id %>% as.character, fill = Treatment)) +
  geom_dotplot(stackgroups = TRUE, binwidth = 1, binpositions = "all") +
  theme_minimal() + scale_x_discrete(limits=father.order) +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  xlab("Father ID") +
  theme(axis.text.y = element_blank(), axis.title.y = element_blank())

ggplot(colony.clusters, aes(x = mother_id %>% as.character, fill = Treatment)) +
  geom_dotplot(stackgroups = TRUE, binwidth = 1, binpositions = "all") +
  theme_minimal() + scale_x_discrete(limits=mother.order) +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  xlab("Mother ID") +
  theme(axis.text.y = element_blank(), axis.title.y = element_blank())


# Plot mother ~ father ID 
ggplotly(
  ggplot(colony.clusters, 
         aes(x=father_id %>% as.character, y=mother_id %>% as.character, colour=Treatment, text=offspring_id)) + #size=probability, 
    geom_point(alpha=0.65, size=5, position = position_dodge(width=0.5)) + theme_minimal() + 
    scale_size_continuous(guide="none") + 
    scale_x_discrete(limits=father.order) +
    scale_y_discrete(limits=mother.order) +
    scale_color_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
    xlab("Father ID") + ylab("Mother ID"), tooltip = "text")

# How many fathers and mothers does each Ph group have? 
colony.clusters %>%
  group_by(Treatment) %>%
  summarise(n_fathers=n_distinct(father_id),n_mothers=n_distinct(mother_id))
```

I used the dotplots to identify parents that contributed multiple offspring in our samples, and selected samples to remove to get rid of siblings. 

```{r}
# Count how many of each treatment remain after removing half and full sibs
`%!in%` = Negate(`%in%`) #function that is the opposite of "%in%"

# Generate a list of samples that should not contain full or half sibs 
nosibs <- (sample.info %>% filter(Sample %!in% c("Tank_13_Crab_2", "Tank_7_Crab_4", "Tank_2_Crab_2", 
               "Tank_11_Crab_1", "Tank_20_Crab_2", "Tank_11_Crab_3", 
               "Tank_3_Crab_2", "Tank_5_Crab_3", "Tank_5_Crab_1", 
               "Tank_7_Crab_3", "Tank_18_Crab_3", "Tank_18_Crab_2", 
               "Tank_4_Crab_3", "Tank_15_Crab_1", "Tank_4_Crab_2", 
               "Tank_10_Crab_3", "Tank_13_Crab_3")))$Sample

# Now double check that we no longer have siblings 
ggplot(colony.clusters %>% filter(offspring_id %in% nosibs), aes(x = father_id %>% as.character, fill = Treatment)) +
  geom_dotplot(stackgroups = TRUE, binwidth = 1, binpositions = "all") +
  theme_minimal() + scale_x_discrete(limits=father.order) +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  xlab("Father ID") +
  theme(axis.text.y = element_blank(), axis.title.y = element_blank())

ggplot(colony.clusters %>% filter(offspring_id %in% nosibs), aes(x = mother_id %>% as.character, fill = Treatment)) +
  geom_dotplot(stackgroups = TRUE, binwidth = 1, binpositions = "all") +
  theme_minimal() + scale_x_discrete(limits=mother.order) +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  xlab("Mother ID") +
  theme(axis.text.y = element_blank(), axis.title.y = element_blank())

# How many samples in each treatment remain? 
colony.clusters %>% filter(offspring_id %in% nosibs) %>% group_by(Treatment) %>% tally()
```


# ----- OUTLIER SNP ANALYSIS ----------# 

# Using PCAdapt to detect outlier loci 

NOTE: Because PCAdapt uses PC eigenvalues to identify outliers, they are not likely different among pH treatments, but rather they differ among the PCA clusters. 

## Read in data 

```{r}
path_to_file <- "../results/genotype/rkc-genome/rkc_rnaseq_genotypes-final_miss25.recode.vcf"
filename <- read.pcadapt(path_to_file, type = "vcf")
```
```{bash}
head "C:\Users\LAURA~1.SPE\AppData\Local\Temp\RtmpSInxz9\file23bd42af761a0.pcadapt"
```

### Create annotation vector

This is the order of samples in the vcf 
```
Tank_10_Crab_1	Tank_10_Crab_2	Tank_10_Crab_3	Tank_11_Crab_1	Tank_11_Crab_2	Tank_11_Crab_3	Tank_13_Crab_1	Tank_13_Crab_2	Tank_13_Crab_3	Tank_15_Crab_1	Tank_15_Crab_2	Tank_15_Crab_3	Tank_16_Crab_1	Tank_16_Crab_2	Tank_16_Crab_4	Tank_18_Crab_1	Tank_18_Crab_2	Tank_18_Crab_3	Tank_1_Crab_1	Tank_1_Crab_2	Tank_1_Crab_3	Tank_20_Crab_1	Tank_20_Crab_2	Tank_20_Crab_3	Tank_2_Crab_1	Tank_2_Crab_2	Tank_2_Crab_3	Tank_3_Crab_1	Tank_3_Crab_2	Tank_3_Crab_3	Tank_4_Crab_1	Tank_4_Crab_2	Tank_4_Crab_3	Tank_5_Crab_1	Tank_5_Crab_2	Tank_5_Crab_3	Tank_7_Crab_1	Tank_7_Crab_3	Tank_7_Crab_4	Tank_9_Crab_1	Tank_9_Crab_2	Tank_9_Crab_3	Tank_9_Crab_4
```

```{r}
tab.annot.gen$sample.id #good, this order (from the SNPRelate analysis) is the same as in the VCF. Can use this to annotate
```

## Choose number k of Principal Components 

To choose K, principal component analysis should first be performed with a large enough number of principal components

The scree plot displays in decreasing order the percentage of variance explained by each PC. Up to a constant, it corresponds to the eigenvalues in decreasing order. The ideal pattern in a scree plot is a steep curve followed by a bend and a straight line. The eigenvalues that correspond to random variation lie on a straight line whereas the ones that correspond to population structure lie on a steep curve. We recommend to keep PCs that correspond to eigenvalues to the left of the straight line (Cattells rule).

The first 8 PC axes could be informative. 

```{r}
x <- pcadapt(input = filename, K = 30, min.maf=0.05)
plot(x, option = "screeplot") + theme_minimal() + scale_x_discrete(limits=seq(1:30))
```

## Further explore data to determine K

Another option to choose the number of PCs is based on the score plot that displays population structure. The score plot displays the projections of the individuals onto the specified principal components. Using the score plot, the choice of K can be limited to the values of K that correspond to a relevant level of population structure.

```{r}
plot(x, option = "scores", i=1, j=2, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=3, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=4, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=5, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=6, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=7, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=8, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=9, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=10, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=11, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=12, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=13, pop=tab.annot.gen$Treatment)
plot(x, option = "scores", j=1, i=14, pop=tab.annot.gen$Treatment)

```

Certainly looks like the first 5 PC axes result in clusters, and additional PC axes results in no clustering. PC5 does indicate some slight differences between low pH and the other treatments (despite existence of outlier)

```{r}
x <- pcadapt(filename, K = 5)
summary(x)
```

Identify the outlier on PC5 - is it Tank & Crab 4?

```{r}
x$scores %>% data.frame() %>% mutate(id=row_number()) %>% arrange(X5)
tab.annot.gen$sample.id[2]
```

A Manhattan plot displays log10 of the p-values.

```{r}
plot(x , option = "manhattan")
```

Check the expected uniform distribution of the p-values using a Q-Q plot

```{r}
plot(x, option = "qqplot")
```

Histogram of p-values confirms that most of the p-values follow an uniform distribution. The excess of small p-values indicates the presence of outliers.
```{r}
hist(x$pvalues, xlab = "p-values", main = NULL, breaks = 50, col = "orange")
```

The presence of outliers is also visible when plotting a histogram of the test statistic Dj.

```{r}
plot(x, option = "stat.distribution") + theme_minimal()
```
## Choosing a cutoff for outlier detection

### q-values

```{r}
qval <- qvalue::qvalue(x$pvalues)$qvalues
alpha <- 0.1
outliers <- which(qval < alpha)
length(outliers)
```

### Benjamini-Hochberg Procedure
```{r}
# padj <- p.adjust(x$pvalues,method="BH")
# alpha <- 0.1
# outliers <- which(padj < alpha)
# length(outliers)
```

### Bonferroni correction
```{r}
# padj <- p.adjust(x$pvalues,method="bonferroni")
# alpha <- 0.1
# outliers <- which(padj < alpha)
# length(outliers)
```

### Association between PCs and outliers

It may be interesting to associate outliers with one of the K principal component to have indication about evolutionary pressure. The function get.pc allows to achieve that:

```{r}
snp_pc <- get.pc(x, outliers)
```

```{r}
x %>% str()
```

```{r}
snps.outlier <- data.frame(locus=(extract.gt(vcf) %>% rownames())[outliers]) %>%
  inner_join(snps.annot %>% mutate(locus=paste(chrom, start.snp+1, sep="_")),
            by="locus")
```

### SNPs that are outliers and are found withing a DEG

```{r}
snps.outlier %>% 
  filter(geneID.gene %in% 
           unique(c(rownames(diffex.AM), rownames(diffex.AL), rownames(diffex.ML)))) # 35 SNPs located in DEGs
```

### SNPs that are outliers & located within genes associated with pH according to WGCNA

```{r}
snps.outlier %>% 
  left_join(geneInfo %>% select(id, moduleColor, GS.pH, p.GS.pH, match(modules.cor,names(geneInfo)), match(modules.p,names(geneInfo))), by=c("geneID.gene"="id")) %>%
  filter(p.GS.pH < 0.05) 
```

### SNPS that are located within genes assigned to pH-associated modules from WGCNA

```{r}
snps.outlier %>% 
  left_join(geneInfo %>% select(id, moduleColor, GS.pH, p.GS.pH, match(modules.cor,names(geneInfo)), match(modules.p,names(geneInfo))), by=c("geneID.gene"="id")) %>%
  filter(moduleColor %in% modules)
```

# Identify outliers using Bayescan

# IMPORTANT - LOOK AT FST VALUES TYPICAL TO SNPS GENERATED FROM RNASEQ DATA 

Bayescan uses its own format for input files. Luckily there's a program that will convert a file in VCF format to Bayescan format, called [PGDspider](). Both Bayescan and PGDSpider are on Sedna, so I ran both programs via the slum script on Sedna, [bayescan.sh](../scripts/bayescan.sh). The input files include: 
- VCF, filtered to a max missingness rate of 30%: [rkc_rnaseq_genotypes-final_miss20.recode.vcf](../results/genotype/rkc_rnaseq_genotypes-final_miss20.recode.vcf).  
- .spid files with PGDSpider settings with 1) pH treatment as the "population" variable [pops-pH.spid](../results/genotype/pops-pH.spid), and 2) IBD cluster id as the "population" variable [pops-cluster.spid](../results/genotype/pops-cluster.spid). 
- Sample ~ Population files, for each Bayescan run. I generate those here: 

```{r}
# define "population" as pH treatment groups 
tab.annot.gen %>% select(sample.id, Treatment) %>% 
  write_delim(file = "../results/genotype/pops.pH.txt", delim = "\t", col_names = F, quote = NULL)

# define "population" using multidimensional scaling analysis clustering 
tab.annot.gen %>% select(sample.id, ibs.cluster) %>% 
  write_delim(file = "../results/genotype/pops.clust.txt", delim = "\t", col_names = F, quote = NULL)
```

## Outlier SNPs identified by Bayescan, using pH as grouping/population variable 

RESULTS: no outlier loci identified between pH treatments using FDR<10%, two outlier with FDR=15%

```{r}
source("../scripts/Bayescan_plot_R.r")
# Read in vcf to extract locus id/order 
vcf.bay <- read.vcfR("../results/genotype/rkc-genome/rkc_rnaseq_genotypes-final_miss25.recode.vcf", verbose = FALSE )

# Any outlier SNPs between pH treatment
out.pH <- plot_bayescan("../results/genotype/bayescan/rkc_miss25_bayescan_outliers_pH_fst.txt",0, FDR=0.1, size = 1)
out.pH.names <- rownames(extract.gt(vcf.bay))[out.pH$outliers] #chromosome 47 and 73
snps.annot %>%filter(snp.id %in% rownames(extract.gt(vcf.bay))[out.pH$outliers])
```

## Outlier SNPs identified by Bayescan, using IBD cluster as grouping/population variable 

RESULTS: 23 outlier loci identified between clusters using FDR<10% (30 using FDR<15%), 7 of which reside in gene coding regions. 

```{r}
source("../scripts/Bayescan_plot_R.r")
out.clust <- plot_bayescan("../results/genotype/bayescan/rkc_miss25_bayescan_outliers_cluster_fst.txt",0, FDR=0.1, size = 1)
out.clust.names <- rownames(extract.gt(vcf.bay))[out.clust$outliers]
snps.annot %>%filter(snp.id %in% rownames(extract.gt(vcf.bay))[out.clust$outliers])

### Cluster-ID'd outliers that are found withing a DEG - there are two, both in the same gene
snps.annot %>%filter(snp.id %in% rownames(extract.gt(vcf.bay))[out.clust$outliers]) %>% 
  filter(geneID.gene %in% snps.degs$geneID.gene) %>%
  dplyr::select(chrom, POS.snp, geneID.gene, hit_desc, e_value)

### Cluster-ID'd outliers that are located within genes associated with pH according to WGCNA - there is one
snps.annot %>%filter(snp.id %in% rownames(extract.gt(vcf.bay))[out.clust$outliers]) %>% 
  filter(geneID.gene %in% snps.wgcna.pH$geneID.gene) %>%
  dplyr::select(chrom, POS.snp, geneID.gene, hit_desc, e_value)

### Cluster-ID'd outliers that are located within genes assigned to pH-associated modules from WGCNA, there are two 
snps.annot %>%filter(snp.id %in% rownames(extract.gt(vcf.bay))[out.clust$outliers]) %>% 
  filter(geneID.gene %in% snps.wgcna.module$geneID.gene) %>%
  dplyr::select(chrom, POS.snp, geneID.gene, hit_desc, e_value)
```

```{r}
bayescan.clust <- data.frame(locus=rownames(extract.gt(vcf.bay))) %>% cbind(
  read.table("../results/genotype/bayescan/rkc_miss25_bayescan_outliers_cluster_fst.txt", sep = "" , header = T,
                     na.strings ="", stringsAsFactors= F)) %>% 
  separate(locus, sep="_", into=c("na1", "na2", "chrom", "pos"), remove = FALSE) %>% select(-na1, -na2) %>%
  mutate(chrom=as.numeric(chrom), pos=as.numeric(pos)) %>% arrange(chrom, locus) %>% mutate(X=seq(1:nrow(.))) %>%
  mutate(interest=case_when(
      locus %in% snps.degs$snp.id ~ "DEG",
      locus %in% snps.wgcna.module$snp.id ~ "WGCNA",
      TRUE ~ "not pH-associated")) %>%
  left_join(snps.annot %>% dplyr::select(snp.id, hit_acc, hit_desc), by = c("locus"="snp.id")) %>%
  mutate(protein=sub("\\[.*", "", hit_desc))

bayescan.pH <- data.frame(locus=rownames(extract.gt(vcf.bay))) %>% cbind(
  read.table("../results/genotype/bayescan/rkc_miss25_bayescan_outliers_pH_fst.txt", sep = "" , header = T,
                     na.strings ="", stringsAsFactors= F)) %>% 
  separate(locus, sep="_", into=c("na1", "na2", "chrom", "pos"), remove = FALSE) %>% select(-na1, -na2) %>%
  mutate(chrom=as.numeric(chrom), pos=as.numeric(pos)) %>% arrange(chrom, locus) %>% mutate(X=seq(1:nrow(.))) %>%
  mutate(interest=case_when(
      locus %in% snps.wgcna.module$snp.id ~ "WGCNA",
      locus %in% snps.degs$snp.id ~ "DEG",
      TRUE ~ "not pH-associated"))
```

# Manhattan plot

```{r}
#devtools::install_github("norment/normentR")
library(normentR)
library(janitor)
#devtools::install_github("eliocamp/ggnewscale")
library(ggnewscale)
library(ggrepel)

axis_set <- bayescan.clust %>% 
 group_by(chrom) %>% 
 summarize(center = mean(X))

axis_set3 <- bayescan.clust %>% 
 group_by(chrom) %>% 
 summarize(center = mean(X))

(manhplot1 <- ggplot(bayescan.clust, aes(x = X, y = fst, 
                                  color = as_factor(chrom)),size=.05)  + 
 ggtitle("Outliers identified among multivariate clusters")+
 geom_point(alpha = 0.5,size=1.2) + theme(legend.position = "none") +
 scale_x_continuous(label = axis_set$chrom, breaks = axis_set$center) +
 #scale_y_continuous(expand = c(0,0), limits = c(0.0, 0.1)) +
 scale_color_manual(values = rep(c("gray72", "grey30"), unique(length(axis_set$chrom))), guide="none") +
 new_scale_color()+
 geom_point(data=bayescan.clust %>% filter(locus %in% out.clust.names),
            aes(x=X,y=fst,color = as_factor(interest)),size=2, alpha=0.5)+
    geom_label_repel(data=bayescan.clust %>% filter(locus %in% out.clust.names),
              aes(label=protein, x=X,y=fst,color = as_factor(interest)), 
              box.padding = 0.8, size=2.5, show.legend = F)+
 #scale_color_manual(values = rep(c("red", "darkred"), unique(length(axis_set3$chrom)))) +
 scale_color_manual(values = c("DEG"="firebrick3", "WGCNA"="springgreen4", "not pH-associated"="royalblue3"), 
                    name="Outlier loci within pH-associated genes:") +
 #scale_size_continuous(range = c(0,3)) +
 ylab(expression(paste("Average ", italic(F)[ST])))+
 labs(x = "Chromosome",size=12) + 
 theme_minimal() +
 theme(
  legend.position = "bottom",
  panel.border = element_blank(),
  panel.grid.major.x = element_blank(),
  panel.grid.minor.x = element_blank(),
  axis.text.x = element_text(angle = 0, size = 4, vjust = 9)
 ) + 
    guides(chrom="none", colour = guide_legend(override.aes = list(size=5))))


```



# Additional PCAs 

## Re-generate PCAs without samples that are related (half- or full-sibs)

```{r}
# PCA using SNPRelate 
pca.nosibs <- snpgdsPCA(genofile, num.thread=2, autosome.only=FALSE, verbose = TRUE, 
                 need.genmat = TRUE, snp.id =snpset.id, sample.id = nosibs)
pc.percent <- pca.nosibs$varprop*100
head(round(pc.percent, 2)) #This is the proportion variance explained by each PC 
tab <- data.frame(sample.id = pca.nosibs$sample.id,
    PC1.gen = pca.nosibs$eigenvect[,1],    # the first eigenvector
    PC2.gen = pca.nosibs$eigenvect[,2],    # the second eigenvector
    PC3.gen = pca.nosibs$eigenvect[,3],    # the third eigenvector
    PC4.gen = pca.nosibs$eigenvect[,4],    # the fourth eigenvector
    PC5.gen = pca.nosibs$eigenvect[,5],    # the fifth eigenvector
    stringsAsFactors = FALSE)

# PCA using prcomp etc., but NOTE that I pull the covariance matrix from the SNPRelate PCA command  
pca.nosibs.princomp.gen <- princomp(covmat=pca.nosibs$genmat, scores=T, cor = F) #specify "covmat" because input is a covariance matrix (not raw data!)
summary(pca.nosibs.princomp.gen)
pca.eigenval(pca.nosibs.princomp.gen)[2,1:5] #The Proporation of Variance (aka %variance)  
screeplot(pca.nosibs.princomp.gen, bstick=TRUE) #PC axes aren't super sign. - just look at PC1 

tab <- data.frame(sample.id = pca.nosibs$sample.id,
    PC1.gen = pca.nosibs.princomp.gen$loadings[,1],    # the first eigenvector
    PC2.gen = pca.nosibs.princomp.gen$loadings[,2],    # the second eigenvector
    PC3.gen = pca.nosibs.princomp.gen$loadings[,3],    # the third eigenvector
    PC4.gen = pca.nosibs.princomp.gen$loadings[,4],    # the fourth eigenvector
    stringsAsFactors = FALSE)

shapiro.test(pca.nosibs.princomp.gen$loadings) #Multivariate normality assumption not met

tab.annot.gen.nosibs <- left_join(tab, sample.info, by=c("sample.id"="Sample")) %>% droplevels() %>%
  mutate(Treatment=as.factor(Treatment))
group.nosibs <- as.factor(tab.annot.gen$Treatment)

# PC1 X PC2
ggplot(tab.annot.gen.nosibs, aes(x=PC1.gen, y=PC2.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC2") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC1 X PC3
ggplot(tab.annot.gen.nosibs, aes(x=PC1.gen, y=PC3.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC3") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC3 (", round(pc.percent[3], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC1 X PC4
ggplot(tab.annot.gen.nosibs, aes(x=PC1.gen, y=PC4.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC4") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC4 (", round(pc.percent[4], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC2 X PC3
ggplot(tab.annot.gen.nosibs, aes(x=PC2.gen, y=PC3.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC2xPC3") + 
  xlab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  ylab(paste("PC3 (", round(pc.percent[3], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC1 X PC2 color coded by tank 
ggplot(tab.annot.gen.nosibs, aes(x=PC1.gen, y=PC2.gen)) + 
  geom_point(aes(col=as.factor(Tank)), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC2 (showing tank no.)") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5)))

save(tab.annot.gen.nosibs, file="../results/genotype/tab.annot.gen.nosibs")
```

## Re-generate PCAs using high Fst loci only (calculated among pH Treatments)

```{r}
# PCA using SNPRelate 
pca.fst <- snpgdsPCA(genofile, num.thread=2, autosome.only=FALSE, verbose = TRUE, 
                 need.genmat = TRUE, snp.id =snps.fst)
pc.percent <- pca.fst$varprop*100
head(round(pc.percent, 2)) #This is the proportion variance explained by each PC 
tab <- data.frame(sample.id = pca.fst$sample.id,
    PC1.gen = pca.fst$eigenvect[,1],    # the first eigenvector
    PC2.gen = pca.fst$eigenvect[,2],    # the second eigenvector
    PC3.gen = pca.fst$eigenvect[,3],    # the third eigenvector
    PC4.gen = pca.fst$eigenvect[,4],    # the fourth eigenvector
    PC5.gen = pca.fst$eigenvect[,5],    # the fifth eigenvector
    stringsAsFactors = FALSE)

# PCA using prcomp etc., but NOTE that I pull the covariance matrix from the SNPRelate PCA command  
pca.fst.princomp.gen <- princomp(covmat=pca.fst$genmat, scores=T, cor = F) #specify "covmat" because input is a covariance matrix (not raw data!)
summary(pca.fst.princomp.gen)
pca.eigenval(pca.fst.princomp.gen)[2,1:5] #The Proporation of Variance (aka %variance)  
screeplot(pca.fst.princomp.gen, bstick=TRUE) #PC axes aren't super sign. - just look at PC1 

tab <- data.frame(sample.id = pca.fst$sample.id,
    PC1.gen = pca.fst.princomp.gen$loadings[,1],    # the first eigenvector
    PC2.gen = pca.fst.princomp.gen$loadings[,2],    # the second eigenvector
    PC3.gen = pca.fst.princomp.gen$loadings[,3],    # the third eigenvector
    PC4.gen = pca.fst.princomp.gen$loadings[,4],    # the fourth eigenvector
    stringsAsFactors = FALSE)

shapiro.test(pca.fst.princomp.gen$loadings) #Multivariate normality assumption met

tab.annot.gen.fst <- left_join(tab, sample.info, by=c("sample.id"="Sample")) %>% droplevels() %>%
  mutate(Treatment=as.factor(Treatment))
group.fst <- as.factor(tab.annot.gen$Treatment)

# PC1 X PC2
ggplot(tab.annot.gen.fst, aes(x=PC1.gen, y=PC2.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC2") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC1 X PC3
ggplot(tab.annot.gen.fst, aes(x=PC1.gen, y=PC3.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC3") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC3 (", round(pc.percent[3], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC1 X PC4
ggplot(tab.annot.gen.fst, aes(x=PC1.gen, y=PC4.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC4") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC4 (", round(pc.percent[4], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC2 X PC3
ggplot(tab.annot.gen.fst, aes(x=PC2.gen, y=PC3.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC2xPC3") + 
  xlab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  ylab(paste("PC3 (", round(pc.percent[3], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC1 X PC2 color coded by tank 
ggplot(tab.annot.gen.fst, aes(x=PC1.gen, y=PC2.gen)) + 
  geom_point(aes(col=as.factor(Tank)), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC2 (showing tank no.)") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5)))

save(tab.annot.gen.fst, file="../results/genotype/tab.annot.gen.fst")
```

# Perform IBS clustering on each treatment separately to identify order for DEG heatmaps 

```{r}
# Ambient pH group
ibs.amb <- snpgdsHCluster(snpgdsIBS(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE, 
                                    sample.id = (sample.info %>% filter(Sample!="Tank_7_Crab_4") %>% 
                                                   filter(Treatment=="Ambient"))$Sample))
rv.amb <- snpgdsCutTree(ibs.amb)
plot(rv.amb$dendrogram, leaflab="perpendicular", main="Ambient Treatment\nHapMap Phase II")
gen.order.amb <- ibs.amb$sample.id[rv.amb$samp.order]

# Moderate pH group
ibs.mod <- snpgdsHCluster(snpgdsIBS(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE, 
                                    sample.id = (sample.info %>% filter(Treatment=="Moderate"))$Sample))
rv.mod <- snpgdsCutTree(ibs.mod)
plot(rv.mod$dendrogram, leaflab="perpendicular", main="Moderate Treatment\nHapMap Phase II")
gen.order.mod <- ibs.mod$sample.id[rv.mod$samp.order]

# Low pH group 
ibs.low <- snpgdsHCluster(snpgdsIBS(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE, 
                                    sample.id = (sample.info %>% filter(Treatment=="Low"))$Sample))
rv.low <- snpgdsCutTree(ibs.low)
plot(rv.low$dendrogram, leaflab="perpendicular", main="Severe Treatment\nHapMap Phase II")
gen.order.low <- ibs.low$sample.id[rv.low$samp.order]
```

# Re-draw gene expression heatmaps, but order samples (columns) to match the order in each of the dendograms generated in previous chunk

```{r}

load(file = "../results/deseq2/diffex.AM.counts")
load(file = "../results/deseq2/diffex.AL.counts")
load(file = "../results/deseq2/diffex.ML.counts")


pheatmap(diffex.AM.counts[,c(gen.order.amb, gen.order.mod)], cluster_cols = FALSE, cluster_rows=TRUE, 
         show_rownames=FALSE, na.rm=TRUE, scale="row", 
         main = "DEGs among pH 8.0 (ambient) & pH 7.8 (moderate)\nGenes (rows) sorted by p-value\nSamples (columns) sorted by genetic clustering",
         fontsize = 8, cutree_rows = 2, 
         annotation_colors = list(Treatment=c(Ambient="#2c7bb6", Moderate="#fdae61")),
         annotation_col=dds.pH.df[colnames(diffex.AM.counts),"Treatment", drop=FALSE])

pheatmap(diffex.AL.counts[,c(gen.order.amb, gen.order.low)], cluster_cols = FALSE, cluster_rows=TRUE, 
         show_rownames=FALSE, na.rm=TRUE, scale="row", 
         main = "DEGs among pH 8.0 (ambient) & pH 7.5 (low)\nGenes (rows) sorted by p-value\nSamples (columns) sorted by genetic clustering",
         fontsize = 8, cutree_rows = 2,
         annotation_colors = list(Treatment=c(Ambient="#2c7bb6", Low="#d7191c")),
         annotation_col=dds.pH.df[colnames(diffex.AL.counts),"Treatment", drop=FALSE])

pheatmap(diffex.ML.counts[,c(gen.order.mod, gen.order.low)], cluster_cols = FALSE, cluster_rows=TRUE, 
         show_rownames=TRUE, na.rm=TRUE, scale="row", 
         main = "DEGs among pH 7.8 (moderate) & pH 7.5 (low)\nGenes (rows) sorted by p-value\nSamples (columns) sorted by genetic clustering",
         fontsize = 8, cutree_rows = 2, 
         annotation_colors = list(Treatment=c(Moderate="#fdae61", Low="#d7191c")),
         annotation_col=dds.pH.df[colnames(diffex.ML.counts),"Treatment", drop=FALSE])
```


# ----------------------------------------------------
# Identifying outlier loci using R package OutFLANK 

OutFLANK's code to use a VCF as input didn't work for me (resulted in all NA values instead of genotypes), so here I will manually generate the genotype matrix 

## Generate genotype matrix from SNPRelate object 

- **SNPRelate codes alleles this way:** "There are four possible values stored in the variable genotype: 0, 1, 2 and 3. For bi-allelic SNP sites, 0 indicates two B alleles, 1 indicates one A allele and one B allele, 2 indicates two A alleles, and 3 is a missing genotype. (When you) take out genotype data with sample and SNP IDs, and four possible values are returned 0, 1, 2 and NA (3 is replaced by NA).  

- **OutFLANK codes alleles this way:** "SNPmat (the input matrix) is an array with a row for each individual in the data set and a column for each locus. This function assumes biallelic (i.e. SNP) data, and the value in each column is either 0, 1 or 2, showing the number of the focal alleles that the individual carries at that locus. (i.e., 2 means that the individual is a homozygote for the focal allele, 0, means that the individual has no copies of that focal allele, and 1 indicates a heterozygote.) For any locus that is unknown for an individual, SNPmat should have a 9 for that locus on that row." 

# ```{r}
# # Extract genotype matrix 
# geno.matrix4outflank <- snpgdsGetGeno(gdsobj="../results/genotype/genotypes.gds", snp.id = snpset.id, with.id=TRUE)
# 
# paste("No. of SNPs for OutFlank analysis: ", ncol(geno.matrix4outflank$genotype), sep="") 
# paste("No. of samples for OutFlank analysis: ", nrow(geno.matrix4outflank$genotype), sep="") 
# 
# # Replace SNPRelate numeric allele coding with character allele coding 
# 
# #SNPRelate: 
# ### 0 =  Homozygous for B
# ### 1 =  Heterozygous
# ### 2 =  Homozygous for A
# ### 3 =  Missing data 
# 
# #OutFLANK:
# ### 0 =  No copies of focal allele
# ### 1 =  Heterozygous
# ### 2 =  Homozygous
# ### 9 =  Missing data 
# 
# geno.matrix4outflank.recode <- geno.matrix4outflank$genotype %>% as_data_frame() %>% 
#   mutate_all(function(x) {
#     case_when(
#       x == 0 ~ 2, 
#       x == 1 ~ 1,
#       x == 2 ~ 2,
#       is.na(x) ~ 9)}) %>% 
#   as.matrix() %>% unname()
# 
# # Spot check that recode worked 
# data.frame(geno.matrix4outflank$genotype %>% as_data_frame() %>% select(V1) %>% as.vector(),
# geno.matrix4outflank.recode %>% as_data_frame() %>% select(V1) %>% as.vector) %>% 
#   rename("V1"="snprelate", "V1.1"="outflank")
# # looks good 
# 
# rownames(geno.matrix4outflank.recode) <- rownames(geno.matrix4outflank)
# ```

## Generate genotype matrix using vcfR 

The VCF specification allows for genotypes to be delimited with a '|' when they are phased and a '/' when unphased. Phased data has identified which one of the pair of chromosomes holds each allele, whereas unphased doesn't identify the chromosomes. 

Since OutFLANK doesn't use phasing information, I will treat the genotype info with "|" and "\" delimiter as the same. 

2 = homozygote for the focal allele (i.e. reference allele) 
0 = no copies of that focal allele
1 = heterozygote
9 = locus is unknown for an individual

```{r}
# Load the data
vcf <- read.vcfR("../results/genotype/rkc-genome/rkc_rnaseq_genotypes-final_miss25.recode.vcf", verbose = FALSE )

# Extract genotype matrix 
geno.matrix4outflank <- extract.gt(vcf) %>% as.data.frame()

paste("No. of SNPs for OutFlank analysis: ", nrow(geno.matrix4outflank), sep="") 
paste("No. of samples for OutFlank analysis: ", ncol(geno.matrix4outflank), sep="") 
```

Here are all the genotype codes in my SNP set

```{r}
as.matrix(geno.matrix4outflank) %>% table()
```

```{r}
# Replace allele coding with:

#OutFLANK:
### 0 =  No copies of focal allele
### 1 =  Heterozygous
### 2 =  Homozygous
### 9 =  Missing data 

geno.matrix4outflank.recode <- geno.matrix4outflank %>% 
  mutate_all(function(x) {
    case_when(
      x == "0/0" ~ 2, # homozygous
      x == "0/1" ~ 1, # heterozygous 
      x == "0/2" ~ 1, # heterozygous
      x == "0|0" ~ 2, # homozygous 
      x == "0|1" ~ 1, # heterozygous
      x == "0|2" ~ 1, # heterozygous       
      x == "1/1" ~ 0, # no copies
      x == "1/2" ~ 0, # no copies       
      x == "1|1" ~ 0, # no copies 
      x == "1|2" ~ 0, # no copies
      x == "2/2" ~ 0, # no copies       
      x == "2|2" ~ 0, # no copies
      x == "3|3" ~ 0, # no copies        
      is.na(x) ~ 9)}) %>% t() %>% as.data.frame() %>% 
  mutate_if(is.numeric,as.integer)

# And I now only have 0, 1, 2, and 9 in the new matrix 
table(as.matrix(geno.matrix4outflank.recode))

# I reviewed the new dataframe visually, and still saw some NA's! 

geno.matrix4outflank.recode[is.na(geno.matrix4outflank.recode)]
```

### Locus names 

```{r}
colnames(geno.matrix4outflank.recode) %>% head()
```

### Sample ids 

#### Again, double check that my sample order is the same in the tab.annot.gen file as in the genofile (which I used to pull the genotype matrix from)

```{r}
# check to make sure samples are in the same order in my genotype matrix and the annotation object 
all(rownames(geno.matrix4outflank.recode) == tab.annot.gen$sample.id) #yes, all=TRUE

# this will be my popNames vector 
as.vector(tab.annot.gen$Treatment)
```

### Calculate variables required for OutFLANK() function

```{r}
# Using pH as grouping variable 
FstDataFrame.pH <- MakeDiploidFSTMat(SNPmat = geno.matrix4outflank.recode, 
                                  locusNames = colnames(geno.matrix4outflank.recode), 
                                  popNames = as.vector(tab.annot.gen$Treatment))
# Using cluster as grouping variable 
FstDataFrame.clust <- MakeDiploidFSTMat(SNPmat = geno.matrix4outflank.recode, 
                                  locusNames = colnames(geno.matrix4outflank.recode), 
                                  popNames = as.vector(tab.annot.gen$ibs.cluster))
```

## OutFLANK QC 

```{r}
# Check for loci with low sample sizes or unusual values of uncorrected FST
# I'm unsure what to do here - I have lots of missing data, indicated by higher uncorrected Fst relative to corrected Fst 

# Using pH as grouping variable 
plot(FstDataFrame.pH$FST, FstDataFrame.pH$FSTNoCorr, 
     xlim=c(-0.01,0.3), ylim=c(-0.01,0.3),
     pch=20)
abline(0,1)

# Check if FST distribution looks chi-squared distributed
plot(FstDataFrame.pH$He, FstDataFrame.pH$FSTNoCorr, pch=20, col="grey")
hist(FstDataFrame.pH$FSTNoCorr, breaks=200)
hist(FstDataFrame.pH$FSTNoCorr[FstDataFrame.pH$He>0.1], breaks=200)
summary(FstDataFrame.pH$He) #He is very high 
hist(FstDataFrame.pH$FST, breaks=200)
summary(FstDataFrame.pH$FST)

# Run outflank
out1.pH <- OutFLANK(FstDataFrame.pH, NumberOfSamples=43)

# Visualize results
OutFLANKResultsPlotter(out1.pH, withOutliers = TRUE,
NoCorr = TRUE, Hmin = 0.1, binwidth = 0.001, Zoom =
FALSE, RightZoomFraction = 0.05, titletext = NULL)
 
hist(out1.pH$results$pvaluesRightTail)
sum(out1.pH$results$qvalues<0.1, na.rm=TRUE) # how many outliers? 
summary(out1.pH$results$qvalues) #none! 


# Using cluster as grouping variable 
plot(FstDataFrame.clust$FST, FstDataFrame.clust$FSTNoCorr, 
     xlim=c(-0.01,0.3), ylim=c(-0.01,0.3),
     pch=20)
abline(0,1)

plot(FstDataFrame.clust$He, FstDataFrame.clust$FSTNoCorr, pch=20, col="grey")
hist(FstDataFrame.clust$FSTNoCorr, breaks=200)
hist(FstDataFrame.clust$FSTNoCorr[FstDataFrame.clust$He>0.1], breaks=200)
summary(FstDataFrame.clust$He) #He is very high 
hist(FstDataFrame.clust$FST, breaks=200)
summary(FstDataFrame.clust$FST)

# Run outflank
out1.clust <- OutFLANK(FstDataFrame.clust, NumberOfSamples=43)

# Visualize results
OutFLANKResultsPlotter(out1.clust, withOutliers = TRUE,
NoCorr = TRUE, Hmin = 0.1, binwidth = 0.001, Zoom =
FALSE, RightZoomFraction = 0.05, titletext = NULL)
 
hist(out1.clust$results$pvaluesRightTail)
sum(out1.clust$results$qvalues<0.1, na.rm=TRUE) # how many outliers? 
summary(out1.clust$results$qvalues) #none! 
```
