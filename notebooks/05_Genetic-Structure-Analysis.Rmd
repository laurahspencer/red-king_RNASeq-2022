---
title: "Genetic Structure Analysis"
author: "Laura H Spencer"
date: "3/24/2022"
output: html_document
---
```{r, message=FALSE, warning=FALSE, results=FALSE}
# Add all required libraries that are installed with install.packages() here
list.of.packages <- c("tidyverse", "reshape2", "plotly", "vcfR", "network", "janitor", "corrplot", "PerformanceAnalytics", "ggpubr", "RColorBrewer", "usedist", "vegan", "forcats", "valr")

# Add all libraries that are installed using BiocManager here
bioconductor.packages <- c("SNPRelate", "DESeq2", "rtracklayer")

# Install BiocManager if needed
if(!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
new.bioc.packages <- bioconductor.packages[!(bioconductor.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
if(length(new.bioc.packages)) BiocManager::install(new.bioc.packages)

# Load all required libraries
all.packages <- c(list.of.packages, bioconductor.packages)
lapply(all.packages, FUN = function(X) {
  do.call("require", list(X))
})

source("../references/biostats.R")
```

## Load sample info and create dataframes for each stage 

```{r}
sample.info <- read.csv("../data/RCK-exp-design.csv", header=T, na.strings = NA)
```

## Use SNPRelate to filter vcf files. Remove: 
- Select biallelic loci only 
- Loci with minor allele frequency < 5%
- Select loci that are present across all samples (missing.rate=0) 

```{r}
#snpgdsClose(genofile)
vcf.fn <- "../results/genotype/rkc_rnaseq_genotypes-filtered-true.vcf.gz"
SNPRelate::snpgdsVCF2GDS(vcf.fn, "../results/genotype/genotypes.gds", method="biallelic.only")
snpgdsSummary("../results/genotype/genotypes.gds")
```

## Open gds and check out genofile contents 

```{r}
(genofile <- snpgdsOpen("../results/genotype/genotypes.gds"))
```
## Prune/Clean SNPs 
- Remove those in linkage-disequilibrium
- Remove those with Minor Allele Frequency <5%
- Remove those that are missing from 20% or more of samples  

```{r}
snpset <- snpgdsLDpruning(genofile, maf=.05, missing.rate=0.20, autosome.only=FALSE)
snpset.id <- unlist(unname(snpset))
```

# `length(snpset.id)` SNPs remain after all filtering steps 

## PCA  

```{r}
# PCA using SNPRelate 
pca <- snpgdsPCA(genofile, num.thread=2, autosome.only=FALSE, verbose = TRUE, 
                 need.genmat = TRUE, snp.id =snpset.id )
pc.percent <- pca$varprop*100
head(round(pc.percent, 2)) #This is the proportion variance explained by each PC 
tab <- data.frame(sample.id = pca$sample.id,
    PC1.gen = pca$eigenvect[,1],    # the first eigenvector
    PC2.gen = pca$eigenvect[,2],    # the second eigenvector
    PC3.gen = pca$eigenvect[,3],    # the third eigenvector
    PC4.gen = pca$eigenvect[,4],    # the fourth eigenvector
    PC5.gen = pca$eigenvect[,5],    # the fifth eigenvector
    stringsAsFactors = FALSE)

# PCA using prcomp etc., but NOTE that I pull the covariance matrix from the SNPRelate PCA command  
pca.princomp.gen <- princomp(covmat=pca$genmat, scores=T, cor = F) #specify "covmat" because input is a covariance matrix (not raw data!)
summary(pca.princomp.gen)
pca.eigenval(pca.princomp.gen)[2,1:5] #The Proporation of Variance (aka %variance)  
screeplot(pca.princomp.gen, bstick=TRUE) #PC axes aren't super sign. - just look at PC1 

tab <- data.frame(sample.id = pca$sample.id,
    PC1.gen = pca.princomp.gen$loadings[,1],    # the first eigenvector
    PC2.gen = pca.princomp.gen$loadings[,2],    # the second eigenvector
    PC3.gen = pca.princomp.gen$loadings[,3],    # the third eigenvector
    PC4.gen = pca.princomp.gen$loadings[,4],    # the fourth eigenvector
    stringsAsFactors = FALSE)

shapiro.test(pca.princomp.gen$loadings) #Multivariate normality assumption not met

tab.annot.gen <- left_join(tab, sample.info, by=c("sample.id"="Sample")) %>% droplevels() %>%
  mutate(Treatment=as.factor(Treatment))
group <- as.factor(tab.annot.gen$Treatment)

# PC1 X PC2
ggplot(tab.annot.gen, aes(x=PC1.gen, y=PC2.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC2") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC1 X PC3
ggplot(tab.annot.gen, aes(x=PC1.gen, y=PC3.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC3") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC3 (", round(pc.percent[3], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC2 X PC3
ggplot(tab.annot.gen, aes(x=PC2.gen, y=PC3.gen)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC2xPC3") + 
  xlab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  ylab(paste("PC3 (", round(pc.percent[3], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(col=Treatment), size=0.3)

# PC1 X PC2 color coded by tank 
ggplot(tab.annot.gen, aes(x=PC1.gen, y=PC2.gen)) + 
  geom_point(aes(col=as.factor(Tank)), size=3.5, alpha=0.75) + 
  theme_minimal() + ggtitle("Genetic Structure, PC1xPC2 (showing tank no.)") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 2), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent[2], digits = 2), "%)", sep="")) + 
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5)))

save(tab.annot.gen, file="../results/genotype/tab.annot.gen")
```

## Distribution of genetic covariance matrix 

```{r}
pca$genmat %>% hist(breaks=100, main="Histogram of genetic covariance\nfrom SNPRelate")
```
```{r}

```

## Relatedness Analysis using SNPRelate 

```{r}
ibd.mle <- snpgdsIBDMLE(genofile, snp.id=snpset.id, maf=0.05, missing.rate=0.20get , num.thread=2, autosome.only = F)

ibd.mle.coeff <- snpgdsIBDSelection(ibd.mle)
head(ibd.mle.coeff)
hist(ibd.mle.coeff$kinship, breaks = 100)
plot(ibd.mle.coeff$k0, ibd.mle.coeff$k1, #xlim=c(0,1), ylim=c(0,1),
    xlab="k0", ylab="k1", main="relatedness (MLE)")
lines(c(0,1), c(1,0), col="red", lty=2)
```


## cluster analysis 

Use SNPRelate to calculate the fraction of identity by state for each pair of samples

```{r}
# To perform cluster analysis on the matrix of genome-wide IBS pairwise distances, 
# and determine the groups by a permutation score. 
# Result= only 1 group (?)
ibs.hc <- snpgdsHCluster(snpgdsIBS(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE))
rv <- snpgdsCutTree(ibs.hc)
plot(rv$dendrogram, leaflab="none", main="HapMap Phase II")

# Determine groups of individuals by treatment information
rv2 <- snpgdsCutTree(ibs.hc, samp.group=tab.annot.gen$Treatment)
plot(rv2$dendrogram, leaflab="none", main="HapMap Phase II")
legend("bottom", legend=levels(group), col=1:nlevels(group), pch=19, ncol=3, cex=0.6, pt.cex=1)
```

Genetic relationship matrix 

```{r}

```

## Allele frequencies 

```{r}
AF.ambient <- snpgdsSNPRateFreq(genofile, snp.id=snpset.id, sample.id=subset(tab.annot.gen, Treatment=="Ambient")$sample.id, with.id = TRUE)

AF.moderate <- snpgdsSNPRateFreq(genofile, snp.id=snpset.id, sample.id=subset(tab.annot.gen, Treatment=="Moderate")$sample.id, with.id = TRUE)

AF.low <- snpgdsSNPRateFreq(genofile, snp.id=snpset.id, sample.id=subset(tab.annot.gen, Treatment=="Low")$sample.id, with.id = TRUE)

AFs <- rbind(
  do.call(cbind.data.frame, AF.ambient[c("snp.id", "AlleleFreq", "MinorFreq", "MissingRate")]) %>% 
    mutate(Treatment=as.factor("Ambient")), 
do.call(cbind.data.frame, AF.moderate[c("snp.id", "AlleleFreq", "MinorFreq", "MissingRate")]) %>% 
  mutate(Treatment=as.factor("Moderate")), 
do.call(cbind.data.frame, AF.low[c("snp.id", "AlleleFreq", "MinorFreq", "MissingRate")]) %>% 
  mutate(Treatment=as.factor("Low")))
```

## Major allele frequency distribution by treatment 

```{r}
ggplot(AFs, aes(x=Treatment, y=AlleleFreq, fill=Treatment)) + geom_violin(trim = F, alpha=0.5) + 
  theme_minimal() + 
  stat_summary(fun.y=mean, geom="point", shape=8, size=4, color="black", fill="black") + 
  xlab("pH exposure") + ylab("Allele Frequency") +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  ggtitle(paste("Major Allele Frequency by pH Treatment\n", 
                "(No. loci = ", length(snpset.id), ")", sep="")) +
    geom_text(data=AFs %>% group_by(Treatment) %>% 
                summarize(mean=mean(AlleleFreq)), 
              aes(x=Treatment, y=mean+.1, label=round(mean, 3)))
```

## Minor allele frequency distribution by treatment 

```{r}
ggplot(AFs, aes(x=Treatment, y=MinorFreq, fill=Treatment)) + 
  geom_violin(trim = F, alpha=0.5) + 
  theme_minimal() + 
  stat_summary(fun.y=mean, geom="point", shape=8, size=4, color="black", fill="black") + 
  xlab("pH exposure") + ylab("Allele Frequency") +
  scale_fill_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c")) +
  ggtitle(paste("Minor Allele Frequency by pH Treatment\n", 
                "(No. loci = ", length(snpset.id), ")", sep="")) +
    geom_text(data=AFs %>% group_by(Treatment) %>% 
                summarize(mean=mean(MinorFreq)), 
              aes(x=Treatment, y=mean+.1, label=round(mean, 3)))
```

##  Fst Calculations 
### Note: snpgdsFst() returns 5 things:
  - sample IDs 
  - SNP ids (i.e. indices)
  - "Fst" = weighted Fst estimate 
  - "MeanFst" = average of Fst estimates across all SNPs 
  - "FstSNP" = A vector of Fst for each SNP 

```{r}

# Fst among all 3 treatments 
Fst <- snpgdsFst(genofile, snp.id=snpset.id, 
                        sample.id=tab.annot.gen$sample.id, 
                  population=tab.annot.gen$Treatment,
    method="W&C84", autosome.only=FALSE, with.id = TRUE)
paste("Weir and Cockerham mean Fst estimate, all treatments compared: ", round(Fst$MeanFst, 5))
hist(Fst$FstSNP, breaks = 75, main="Fst distribution", col="dodgerblue3")

Fst.AM <- snpgdsFst(genofile, snp.id=snpset.id, 
                        sample.id=subset(tab.annot.gen, Treatment %in% c("Ambient", "Moderate"))$sample.id, 
               population=droplevels(subset(tab.annot.gen, Treatment %in% c("Ambient", "Moderate"))$Treatment),
    method="W&C84", autosome.only=FALSE, with.id = TRUE)
paste("Weir and Cockerham mean Fst estimate, Ambient vs Moderate: ", round(Fst.AM$MeanFst, 5))
hist(Fst.AM$FstSNP, breaks = 75, main="Fst distribution", col="dodgerblue3")

Fst.AL <- snpgdsFst(genofile, snp.id=snpset.id, 
                        sample.id=subset(tab.annot.gen, Treatment %in% c("Ambient", "Low"))$sample.id, 
               population=droplevels(subset(tab.annot.gen, Treatment %in% c("Ambient", "Low"))$Treatment),
    method="W&C84", autosome.only=FALSE, with.id = TRUE)
paste("Weir and Cockerham mean Fst estimate, Ambient vs Low: ", round(Fst.AL$MeanFst, 5))
hist(Fst.AL$FstSNP, breaks = 75, main="Fst distribution", col="dodgerblue3")

Fst.ML <- snpgdsFst(genofile, snp.id=snpset.id, 
                        sample.id=subset(tab.annot.gen, Treatment %in% c("Moderate", "Low"))$sample.id, 
               population=droplevels(subset(tab.annot.gen, Treatment %in% c("Moderate", "Low"))$Treatment),
    method="W&C84", autosome.only=FALSE, with.id = TRUE)
paste("Weir and Cockerham mean Fst estimate, Moderate vs Low: ", round(Fst.ML$MeanFst, 5))
hist(Fst.ML$FstSNP, breaks = 75, main="Fst distribution", col="dodgerblue3")

Fsts <- rbind(
  
  do.call(cbind.data.frame, Fst[c("snp.id", "FstSNP")]) %>% mutate(contrast=as.factor("all")), 

  do.call(cbind.data.frame, Fst.AM[c("snp.id", "FstSNP")]) %>% mutate(contrast=as.factor("AvsM")),

  do.call(cbind.data.frame, Fst.AL[c("snp.id", "FstSNP")]) %>% mutate(contrast=as.factor("AvsL")),

  do.call(cbind.data.frame, Fst.ML[c("snp.id", "FstSNP")]) %>% mutate(contrast=as.factor("MvsL"))) 

ggplot(Fsts, aes(x=contrast, y=FstSNP, fill=contrast)) + geom_violin(trim = F) + 
  stat_summary(fun.y=mean, geom="point", shape=8, size=3.5, color="black", fill="black") +
  ggtitle(paste("SNP Fst, Adults by pCO2 treatment\n", "(No. loci = ", length(snpset.id), ")", sep="")) +
    geom_text(data=Fsts %>% group_by(contrast) %>% summarize(mean=mean(FstSNP)), aes(x=contrast, y=.65, label=round(mean, 3)))
```

## Adult Identity-by-state 

```{r}
lbls <- paste("PC", 1:4, "\n", format(pc.percent[1:4], digits=2), "%", sep="")
pairs(pca$eigenvect[,1:4], col=as.color(tab.annot.gen$Treatment), labels=lbls, main="Colors = pH Treatment")
pairs(pca$eigenvect[,1:4], col=as.color(tab.annot.gen$Tank), labels=lbls, main="Colors = Tank")
```
## Multidimensional scaling analysis using Identity-By-State (IBS) proportion
```{r}
ibs <- snpgdsIBS(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE)
pop.idx <- order(tab.annot.gen$Treatment)

#par(xpd=TRUE)
#heatmap(ibs$ibs, col=terrain.colors(16), labCol=TRUE, 
#        RowSideColors=c("black","red","green","blue")[tab.annot.gen$pop_code])
#legend(0,-.05, legend=levels(tab.annot.gen$pop_code), pch="o", col=1:nlevels(tab.annot.gen$pop_code), 
#       text.col=1:nlevels(tab.annot.gen$pop_code), cex=.75, ncol=4)

#Perform multidimensional scaling analysis on the matrix of genome-wide IBS pairwise distances:
loc <- cmdscale(1 - ibs$ibs, k = 2)
x <- loc[, 1]; y <- loc[, 2]

plot(x, y, col=group, xlab = "", ylab = "",
    main = "Multidimensional Scaling Analysis (IBS)", cex=2, pch=16)
#text(x, y+.01, labels=tab.annot.gen$sample.id, cex=0.7, font=2, col=as.integer(group))
legend("bottomright", legend=levels(group), pch="o", text.col=1:nlevels(group))
```
## Distribution of genetic covariance matrix 

```{r}
ibs$ibs %>% hist(breaks=100, main="Histogram of Identity-By-State proportion\nfrom SNPRelate")
```
```{r}
test <- snpgdsGRM(genofile, snp.id=snpset.id, num.thread=2, autosome.only=FALSE, method="GCTA")
test$grm %>% hist(breaks=100, main="Histogram of genetic relationship matrix, method=GCTA\nfrom SNPRelate", prob=TRUE)

```


## Correlation analysis, Genetic PCAs ~ Expression PCAs 

### Generage PCAs from expression data for integration 

#### PCA with all genes using princomp and showing broken stick 

```{r}
load(file = "../results/deseq2/vsd.pH") #vsd.pH
pca.princomp.expr <- prcomp(cov(assay(vsd.pH)), scale=F) #scale=F for variance-covariance matrix
pca.eigenval(pca.princomp.expr) #The Proporation of Variance = %variance 
(pc.percent <- pca.eigenval(pca.princomp.expr)[2,1:4]*100)
screeplot(pca.princomp.expr, bstick=TRUE) #looks like PC 1-2 are significant, but also pull the 3rd 
tab.expr <- data.frame(sample.id = colnames(assay(vsd.pH)),
    PC1.expr = pca.princomp.expr$x[,1],    # the first eigenvector
    PC2.expr = pca.princomp.expr$x[,2],    # the second eigenvector
    PC3.expr = pca.princomp.expr$x[,3],    # the third eigenvector
    PC4.expr = pca.princomp.expr$x[,4],    # the fourth eigenvector
    stringsAsFactors = FALSE)
shapiro.test(pca.princomp.expr$x) #multivariate normality not met 
tab.expr.annot <- left_join(tab.expr, sample.info, by=c("sample.id"="Sample")) %>% droplevels()
group.expr <- as.factor(tab.expr.annot$Treatment)
```

```{r}
ggplot(tab.expr.annot, aes(x=PC1.expr, y=PC2.expr)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.85) + 
  theme_minimal() + ggtitle("Expression, all genes, PC1xPC2") + 
  xlab(paste("PC1 (", round(pc.percent[1], digits = 1), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent[2], digits = 1), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(color=Treatment), size=0.3)

save(tab.expr.annot, file="../results/genotype/tab.expr.annot")

# # GGSCATTER with ellipses and stars 
# ggscatter(tab.expr.annot, x="PC1.expr", y="PC2.expr",
#           color="Treatment", size=3.5, alpha=0.85, 
#            palette = c("#2c7bb6","#fdae61", "#d7191c"),
#    ellipse = TRUE, star.plot = TRUE) + 
#   theme_minimal() + ggtitle("Expression, all genes, PC1xPC2") + 
#   xlab(paste("PC1 (", round(pc.percent[1], digits = 1), "%)", sep="")) + 
#   ylab(paste("PC2 (", round(pc.percent[2], digits = 1), "%)", sep="")) + 
#   theme(legend.position = "right") + 
#   guides(colour = guide_legend(override.aes = list(size=3.5))) 
```

## PCA with gene set that are DEGs among any pH comparison 

```{r}
# load in DEG lists 
load(file = "../results/deseq2/diffex.AM")
load(file = "../results/deseq2/diffex.AL")
load(file = "../results/deseq2/diffex.ML")

pca.princomp.expr.pH <-
  princomp(cov(assay(vsd.pH[unique(c(rownames(diffex.AM),rownames(diffex.AL),rownames(diffex.ML))),])))
pca.eigenval(pca.princomp.expr.pH) #The Proporation of Variance = %variance 
(pc.percent.pH <- pca.eigenval(pca.princomp.expr.pH)[2,1:4]*100)
screeplot(pca.princomp.expr.pH, bstick=TRUE) #looks like PC 1 & 2
tab.expr.pH <- data.frame(sample.id = colnames(assay(vsd.pH)),
    PC1.degs = pca.princomp.expr.pH$scores[,1],    # the first eigenvector
    PC2.degs = pca.princomp.expr.pH$scores[,2],    # the second eigenvector
    PC3.degs = pca.princomp.expr.pH$scores[,3],    # the third eigenvector
    PC4.degs = pca.princomp.expr.pH$scores[,4],    # the third eigenvector
    stringsAsFactors = FALSE)
tab.expr.pH.annot <- left_join(tab.expr.pH, sample.info, by=c("sample.id"="Sample")) %>% droplevels()
group.pH.expr <- as.factor(tab.expr.pH.annot$Treatment)
```

```{r}
ggplot(tab.expr.pH.annot, aes(x=PC1.degs, y=PC2.degs)) + 
  geom_point(aes(col=Treatment), size=3.5, alpha=0.85) + 
  theme_minimal() + ggtitle("Expression PC1xPC2, DEGs in response to pH") + 
  xlab(paste("PC1 (", round(pc.percent.pH[1], digits = 1), "%)", sep="")) + 
  ylab(paste("PC2 (", round(pc.percent.pH[2], digits = 1), "%)", sep="")) + 
  theme(legend.position = "right") + 
  scale_color_manual(values = c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  stat_ellipse(aes(color=Treatment), size=0.3)
save(tab.expr.pH.annot, file="../results/genotype/tab.expr.pH.annot")
```
## Merge PC axes from genetic analyis, expression analysis using all data, and expression analysis using DEGs only  

```{r}
PCA.merged <- left_join(left_join(
  tab.annot.gen %>% select(sample.id, Treatment, Tank, starts_with("PC")),
  tab.expr.annot %>% select(starts_with("PC"),sample.id), by=c("sample.id")), 
  tab.expr.pH.annot %>% select(starts_with("PC"),sample.id), by=c("sample.id"))
```

## Examine correlation among genetic and expression PC axes

```{r}
chart.Correlation(PCA.merged %>% select(starts_with("PC")), histogram=F, pch=19, method = "pearson")
mtext("PC Axes Correlation, Genetic (.gen) ~ Expression (.all & .degs)", side=3, line=1.25)
```
Correlated PC axes: 
- PC2.gen x PC4.degs (positive correlation, highly significant)
- PC1.gen x PC3 expr (negativel ycorrelated, modestly significant)
- PC2.gen x PC3 expr (negativel ycorrelated, modestly significant)

```{r}
# PCA.merged.4plots <- PCA.merged %>% dplyr::select(PC1.gen, PC2.gen, PC3.expr, PC4.degs) %>% 
#   pivot_longer(cols = c(PC3.expr, PC4.degs), values_to = "score", names_to = "PC.expr") %>% 
#   mutate(PC.expr=as.factor(PC.expr))

# Most significant correlation, PC2.gen x PC4.degs
ggscatter(PCA.merged, x="PC2.gen", y="PC4.degs", add="reg.line", conf.int = TRUE,
          color="white", 
          add.params = list(color = "gray50", fill = "gray70")) + 
    ggtitle("Genetic PC2 ~ Expression (DEGs only) PC4 Axes") + 
  xlab("Genetic PC2") + ylab("DEGs PC4") + 
  stat_cor(method = "pearson", show.legend=FALSE) +
  theme_pubclean() +theme(legend.position = "bottom") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)

# Modestly sign. correlation
ggscatter(PCA.merged, x="PC1.gen", y="PC3.expr", add="reg.line", conf.int = TRUE,
          color="white", 
          add.params = list(color = "gray50", fill = "gray70")) + 
    ggtitle("Genetic PC1 ~ Expression (all genes) PC3 Axes") + 
  xlab("Genetic PC1") + ylab("DEGs PC4") + 
  stat_cor(method = "pearson", show.legend=FALSE) +
  theme_pubclean() +theme(legend.position = "bottom") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)

# Modestly sign. correlation
ggscatter(PCA.merged, x="PC2.gen", y="PC3.expr", add="reg.line", conf.int = TRUE,
          color="white", 
          add.params = list(color = "gray50", fill = "gray70")) + 
    ggtitle("Genetic PC2 ~ Expression (all genes) PC3 Axes") + 
  xlab("Genetic PC2") + ylab("DEGs PC4") + 
  stat_cor(method = "pearson", show.legend=FALSE) +
  theme_pubclean() +theme(legend.position = "bottom") + 
  scale_color_manual(values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"), name="pH Treatment") +
  guides(colour = guide_legend(override.aes = list(size=3.5))) + 
  geom_point(aes(col=Treatment), alpha=0.85, size=1.8)

# Run linear models 
# Normal? 
hist(PCA.merged$PC1.gen)
hist(PCA.merged$PC2.gen)
hist(PCA.merged$PC4.degs)
hist(PCA.merged$PC3.expr)
shapiro.test(PCA.merged$PC1.gen)
shapiro.test(PCA.merged$PC2.gen)
shapiro.test(PCA.merged$PC4.degs)
shapiro.test(PCA.merged$PC3.expr)

# Examine linear relationship between Expression PC axes and genetic PC axes, also testing for effect of & interaction with Treatment 
anova(lm(PC4.degs ~ PC2.gen*Treatment, data=PCA.merged)) 
anova(lm(PC3.expr ~ PC1.gen*Treatment, data=PCA.merged)) 
anova(lm(PC3.expr ~ PC2.gen*Treatment, data=PCA.merged)) 
```


## Correlation between pairwise genetic distances and expression distances 

Step 1: generate pairwise genetic distances between samples based on SNPs
Step 2: generate pairwise distance matrices from expression data using: 
  - All expressed genes
  - pH-DEGs
Step 3: Calculate Pearson & Spearman correlations between genetic and expression distances 

### Source of distance matrices: 
  - For **genetic pairwise distances** the SPRelate Identiy-By-State analysis produced an nxn matrix of genome-wide average IBS pairwise identities
  - For **expression pairwise distances**  DESeq2 is used to calculate  Euclidean distance between samples on the rlog-transformed count data. 

```{r}
# Genetic distance matrices 
snp.dists <- ibs$ibs %>% `colnames<-` (ibs$sample.id) %>% `rownames<-` (ibs$sample.id)

# Expression distance matrices, ALL expression data   
sampleDistss <- dist(t(assay(vsd.pH)))

# Expression distance matrix, pH DEGs 
sampleDistss.pH <- dist(t(assay(vsd.pH[rownames(vsd.pH) %in%
  unique(c(rownames(diffex.AM),rownames(diffex.AL),rownames(diffex.ML))),])))

# Create list of samples that are found in both the genetic and expression distance matrices 
dist.sampless <- c(as.matrix(sampleDistss) %>% rownames())[c(as.matrix(sampleDistss) %>% rownames()) %in% rownames(snp.dists)]

# Subset each distance matrix to only include samples found in both 
snp.dists.filt <- dist_subset(d=snp.dists, idx=dist.sampless) # genetic distance matrix, common samples
sampleDistss.filt  <- dist_subset(d=sampleDistss, idx=dist.sampless) # expression distance matrix, common samples
sampleDistss.pH.filt  <- dist_subset(d=sampleDistss.pH, idx=dist.sampless) # DEG distance matrix, common samples

# Check to see if matrices are in same order 
all(snp.dists.filt %>% as.matrix() %>% rownames() == sampleDistss.filt %>% as.matrix() %>% rownames()) # yes! 

# Perform correlation 
plot(x=snp.dists.filt, y=sampleDistss.filt, main="Correlation between pairwise distances\nSNP-based ~ Expr-based")
plot(x=snp.dists.filt, y=sampleDistss.pH.filt, main="Correlation between pairwise distances\nSNP-based ~ DEG-based")
```
```{r}
# Perform mantel test 
mantel(snp.dists.filt, sampleDistss.filt, permutations=9999 ) #distance matrices are not sign. correlated 
mantel(snp.dists.filt, sampleDistss.pH.filt, permutations=9999 ) #distance matrices are not sign. correlated 

distancess <- cbind(
  melt(as.matrix(sampleDistss.filt), varnames = c("row", "col"), value.name = "expr.all"),
melt(as.matrix(sampleDistss.pH.filt), varnames = c("row", "col"), value.name = "expr.pH")["expr.pH"],
melt(as.matrix(snp.dists.filt), varnames = c("row", "col"), value.name = "snp")["snp"])

# remove 0 distances and join with factors (population, pCO2 treatment)
distancess <- distancess %>% 
  dplyr::filter(snp!=0) %>% 
  left_join((sample.info %>% 
               dplyr::select(Sample, Treatment)), by=c("row"="Sample")) %>%
  mutate(Treatment=as.factor(Treatment))

# Inspect expression distance matrices vs. snp distance matrix for possible correlations? 
chart.Correlation(distancess[3:5] %>% filter(expr.all!=0),histogram=F, pch=19) #snp vs. expr & deg correlation are both weak but significant 

cor.test(distancess$snp, distancess$expr.all, method = "pearson") #cor -0.15
cor.test(distancess$snp, distancess$expr.pH, method = "pearson") #cor -0.08

ggscatter(distancess, x = "snp", y = "expr.all", size=1,
   add = "reg.line",  # Add regressin line
   add.params = list(color = "black", fill = "gray50"), # Customize reg. line
   conf.int = TRUE # Add confidence interval
   ) + stat_cor(method = "pearson", size=5, colour="red") +
  xlab("Genetic Distance") + ylab("Expression Distance") + 
  ggtitle("Sample-sample distances, SNPs ~ All genes") +
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5)))

ggscatter(distancess, x = "snp", y = "expr.pH", size=1,
   add = "reg.line",  # Add regressin line
   add.params = list(color = "black", fill = "gray50"), # Customize reg. line
   conf.int = TRUE # Add confidence interval
   ) + stat_cor(method = "pearson", size=5, colour="red") +
  xlab("Genetic Distance") + ylab("Expression Distance") + 
  ggtitle("Sample-sample distances, SNPs ~ DEGs only") +
  theme(legend.position = "right") + 
  guides(colour = guide_legend(override.aes = list(size=3.5)))
```

## Are there any SNPs located in genes that are differentially expressed? 

### First create a vcf of SNPs filtered for loci with max 20% missing rate, and remove loci with <5% minor allele frequency
I did this on Sedna using the slurm script [filter-vcf.sh])(../scripts/filter-vcf.sh), which executed the following code:
```
vcftools --gzvcf \
"/scratch/lspencer/2022-redking-OA/genotypes/rkc_rnaseq_genotypes-filtered-true.vcf.gz" \
--max-missing 0.80 --maf 0.05 --recode --recode-INFO-all --out \
"/scratch/lspencer/2022-redking-OA/genotypes/rkc_rnaseq_genotypes-final"
```
This created the file rkc_rnaseq_genotypes-final.recode.vcf  

```{r}
# next load that vcf
vcf.corr <- read.vcfR("../results/genotype/rkc_rnaseq_genotypes-final.recode.vcf", verbose = FALSE )
# It results in 1,429 SNPs, which does not match SNPRelate's number (1,355). Why? 

# Use vcfR to generate a dataframe with snp location information. Also generates a ton of other info 
(snps.map <- genetic_diff(vcf.corr, pops = as.factor(sample.info$Treatment), method = 'nei') %>% 
  mutate(POS=as.numeric(POS)) %>% mutate(start=POS-1, end=POS+1) %>% rename("CHROM"="chrom"))
```

```{r}
load(file = "../references/P.plat.bestblast")
genes <- read_delim(file = "../references/P.platypus_genes.bed", delim = "\t", col_names = c("chrom", "start", "end", "geneID"))

# Look for intersection among snps, genes, and DEGs 
bed_intersect(x=genes, y=snps.map %>% select(chrom, start, end), suffix = c(".gene", ".snp")) %>% #286 SNPs located in known genes 
  left_join(P.plat.bestblast, by = c("geneID.gene"="id_gtf")) %>% #annotate genes containing SNPs 
  filter(geneID.gene %in% unique(c(rownames(diffex.AM), rownames(diffex.AL), rownames(diffex.ML)))) # 35 SNPs located in DEGs
  
# Look for intersection among snps, genes, and WGCNA modules 
load("../results/wgcna/geneInfo")
load(file="../results/wgcna/modules")
load(file="../results/wgcna/modules.p")
load(file="../results/wgcna/modules.cor")

bed_intersect(x=genes, y=snps.map %>% select(chrom, start, end), suffix = c(".gene", ".snp")) %>% #286 SNPs located in known genes 
  left_join(P.plat.bestblast, by = c("geneID.gene"="id_gtf")) %>% #annotate genes containing SNPs 
  left_join(geneInfo, by=c("geneID.gene"="id"))
  filter(geneID.gene %in% unique(c(rownames(diffex.AM), rownames(diffex.AL), rownames(diffex.ML)))) # 35 SNPs located in DEGs
```


# Identify genes wit SNPs and calculate Fst of thoes genes 

```{r}
readr::write_delim(snps.map %>% mutate(start=POS.orig-1, stop=POS.orig+1)  %>% dplyr::select(NAME, start, stop) %>% dplyr::rename(chr=NAME),
                   "../results/SNPs.bed",  delim = '\t', col_names = FALSE)

#Olurida_gene_uniprot %>% dplyr::select(contig, start, end)
```

### Identify genes containing SNPs 

```{bash}
intersectBed \
  -wb \
  -a "../results/SNPs.bed" \
  -b "../references/Olurida_v081-20190709.gene.gff" \
  > "../results/SNPs.genes.tab"
```

### Here is the number of DML loci associated with DM gene regions: 

```{bash}
wc -l "../results/SNPs.genes.tab"
```

```{r}
# Read in O. lurida file with genes that contain SNPs - are any also differentially expressed in adults?  
SNPs.geness <- read_delim(file = "../results/SNPs.genes.tab", delim = "\t", col_names = c("contig.SNP", "start.SNP", "end.SNP", "contig", "source", "feature", "start", "end", "unknown1", "strand", "unknown2", "notes")) %>%
# Split giant gene "Notes" column into separate columns 
  mutate(ID=str_extract(notes, "ID=(.*?);"),
       Parent=str_extract(notes, "Parent=(.*?);"),
       Name=str_extract(notes, "Name=(.*?);"),
       Alias=str_extract(notes, "Alias=(.*?);"),
       AED=str_extract(notes, "AED=(.*?);"),
       eAED=str_extract(notes, "eAED=(.*?);"),
       Note=str_extract(notes, "Note=(.*?);"),
       Ontology_term=str_extract(notes, "Ontology_term=(.*?);"),
       Dbxref=str_extract(notes, "Dbxref=(.*?);"),
       SPID=str_extract(notes, "SPID=(.*?);")
       ) %>% 
  
  #remove extraneous info from Olur gene ID and Uniprot species ID ("SPID")
  mutate(Name=str_remove(Name, "Name=")) %>% mutate(Name=str_remove(Name, ";")) %>%
  mutate(SPID=str_remove(SPID, "SPID=")) %>% mutate(SPID=str_remove(SPID, ";"))

# Write to bedtools to look at all SNPs with alignment data and genes 
write_delim(SNPs.geness %>% dplyr::select(contig.SNP, start.SNP, end.SNP, Name), file = "../results/SNPs.genes.bed", col_names = FALSE, delim = "\t")

# Are any genes with SNPs differentially expressed? 

# Adult DEGs by pco2, all pops combined
SNPs.geness %>% filter(Name %in% rownames(diffex %>% as.data.frame())) %>% dplyr::select(contig.SNP, start.SNP, end.SNP, Name, Note, SPID)
100*(2/71)

# Adult DEGs by pco2, FB
SNPs.geness %>% filter(Name %in% rownames(diffex.FB %>% as.data.frame())) %>% dplyr::select(contig.SNP, start.SNP, end.SNP, Name, Note, SPID)
100*(5/76)

# Adult DEGs by pco2, DB 
SNPs.geness %>% filter(Name %in% rownames(diffex.DB %>% as.data.frame())) %>% dplyr::select(contig.SNP, start.SNP, end.SNP, Name, Note, SPID)
100*(3/132)

# Adult DEGs by population, DB vs FB 
SNPs.geness %>% filter(Name %in% rownames(diffex.DBFB %>% as.data.frame())) %>% dplyr::select(contig.SNP, start.SNP, end.SNP, Name, Note, SPID)
100*(32/689)

# Adult DEGs by pco2, DB vs OB1 
SNPs.geness %>% filter(Name %in% rownames(diffex.DBOB1 %>% as.data.frame())) %>% dplyr::select(contig.SNP, start.SNP, end.SNP, Name, Note, SPID)
100*(47/1107)

# Adult DEGs by pco2, FB vs OB1 
SNPs.geness %>% filter(Name %in% rownames(diffex.FBOB1 %>% as.data.frame())) %>% dplyr::select(contig.SNP, start.SNP, end.SNP, Name, Note, SPID)
100*(3/450)
```








# CODE NOT YET USED 


# More analysis via vcfR - compare allelic richness and heterozygosity by population, stage and parental pCO2 exposure 

First filter the vcf files for each stage (adult, larvae, adult) to remove loci with tons if missing data. Do this via vcftools. 

I used [this tutorial](http://www.ddocent.com/filtering/) as an example. 
  - call vcftools
  - feed it a vcf file after the --vcf flag
  - Set --max-missing 0.90 to keep only loci with 10% missing genotypes across all individuals
  - The --recode flag tells the program to write a new vcf file with the filters
  - The --recode-INFO-all keeps all the INFO flags from the old vcf file in the new one. 
  - Lastly, --out designates the name of the output
  
```{bash}
# adults 
vcftools --gzvcf "../results/genotype/rkc_rnaseq_genotypes-filtered-true.vcf.gz" \
--max-missing 0.85 --recode --recode-INFO-all --out \
"../results/genotype/rkc_rnaseq_genotypes-adult-4vcfR"
```
```{r}
# Load the data
vcf <- read.vcfR("../qc-processing/gatk/Olurida_QuantSeq2020_genotypes-adult-4vcfR.recode.vcf", verbose = FALSE )

# Quantify missing data for each sample 
myMiss <- apply(extract.gt(vcf), MARGIN = 2, function(x){ sum(is.na(x)) })
myMiss <- myMiss/nrow(vcf)
par(mar = c(12,4,4,2))
barplot(myMiss, las = 2)
title(ylab = "Adult Sample Missingness (%)")

# Confirm order of samples in vcf matches order of samples in the "sample.info" dataframe 
colnames(extract.gt(vcf)) == sample.info$sample #yes, all are TRUE

# How many samples per pop + parental pCO2 treatment?
nsamples <- sample.info[match(colnames(extract.gt(vcf)), sample.info$sample),] %>% group_by(population, Treatment) %>% count()

# Calculate differentiation / diversity stats for all population + pCO2 groups 
myDiff <- genetic_diff(vcf, pops = sample.info$pop_code, method = 'nei')
paste("No. SNPs included in this vcfR analysis, adults ", nrow(myDiff), sep="")

# Summarize diversity indices (mean)
knitr::kable(round(colMeans(myDiff[,-1:-2], na.rm = TRUE), digits = 3))

# # Violin plots of Heterozygosity 
# dpf <- melt(myDiff[,c(3:8)], varnames=c('Index', 'Sample'), value.name = 'Depth', na.rm=TRUE) %>%
#   mutate(population=substring(variable, 4)) %>% separate(population, into = c("population", "pCO2"), sep = "-") %>%
#   mutate(population=as.factor(population), pCO2=as.factor(pCO2))
# 
# ggplot(dpf, aes(x=population:pCO2, y=Depth)) + geom_violin(aes(fill=population, alpha=pCO2), adjust = 1.2) + xlab("") + ylab("") + theme_bw() +
#     theme(axis.text.x = element_text(size=7, angle=50, hjust=1)) + ggtitle(paste("Heterozygosity, Adults \nNo. SNPs =", nrow(myDiff))) +  
#   scale_alpha_discrete(range = c(0.35, 0.9)) +
#         stat_summary(fun.y=mean, geom="point", shape=15, size=3, color="black", fill="black") +
#     geom_text(data=dpf %>% group_by(population, pCO2) %>% summarize(mean=mean(Depth)), aes(x=population:pCO2, y=-0.05, label=round(mean, 2)), size=3) + 
#   scale_alpha_discrete(guide="none")

# Boxplots of allelic richness 
dpf.n <- melt(myDiff[,c(10:15)], varnames=c('Index', 'Sample'), value.name = 'Depth', na.rm=TRUE) %>%
  mutate(population=substring(variable, 3)) %>% separate(population, into = c("population", "pCO2"), sep = "-") %>%
  mutate(population=as.factor(population), pCO2=as.factor(pCO2))

ggplot(dpf.n, aes(x=population:pCO2, y=Depth)) + geom_violin(aes(fill=population, alpha=pCO2), adjust = 1.2) + xlab("") + ylab("") + theme_bw() +
    theme(axis.text.x = element_text(size=7, angle=50, hjust=1)) + ggtitle(paste("Allelic Richness, Adults \nNo. SNPs =", nrow(myDiff))) +  
  scale_alpha_discrete(range = c(0.35, 0.9)) +
        stat_summary(fun.y=mean, geom="point", shape=15, size=3, color="black", fill="black") +
    geom_text(data=dpf.n %>% group_by(population, pCO2) %>% summarize(mean=mean(Depth)), aes(x=population:pCO2, y=18.5, label=round(mean, 2)), size=3) + 
    geom_text(data=nsamples, aes(x=as.factor(population):as.factor(Treatment), y=20, label=paste("n=",n, sep="")), size=3)  +
  scale_alpha_discrete(guide="none")
```




# Identify siblings using Colony 

I will use Colony to identify siblings in my samples. The Colony software is only available via the command line for Mac users (it's typically used via GUI on Windows). To get the most current version of the program I actually had to email the developer. He send me a link to download it. I'm running Colony Version 2.0.6.6 (June 30, 2020), which is saved on my computer and in this project's repo (references/colony2.mac.20200904).

Prepare files for Colony sibship analysis
Colony identifies siblings, which I would like to do with my juveniles. Here I prepare files for Colony.

Mac suggested that I only keep SNPs with very high minor allele frequencies. Here I use SNPRelate to export SNPs with MAF >=2%. 

## Adult Sibship analysis via Colony 

```{r}
snpset.4Colony <- snpgdsLDpruning(genofile, maf=.2, missing.rate=0, autosome.only=FALSE)
snpset.id.4Colony <- unlist(unname(snpset.4Colony))
snpgdsCreateGenoSet(src.fn="../results/genotype/genotypes.gds",
                    dest.fn="../qc-processing/colony/genotypes-adult-4Colony.gds",
                    snp.id=snpset.id.4Colony)
```

## Recode genotypes for Colony 

- **SNPRelate codes alleles this way:** "There are four possible values stored in the variable genotype: 0, 1, 2 and 3. For bi-allelic SNP sites, “0” indicates two B alleles, “1” indicates one A allele and one B allele, “2” indicates two A alleles, and “3” is a missing genotype. (When you) take out genotype data with sample and SNP IDs, and four possible values are returned 0, 1, 2 and NA (3 is replaced by NA).  

- **Colony codes alleles this way:** "The first column gives the individual ID (a string containing a maximum of 20 letters and/or numbers, no other characters are allowed), the 2nd and 3rd columns give the alleles observed for the individual at the first locus, the 4th and 5th give the alleles observed for the individual at the 2nd locus ... An allele is identified by an integer, in the range of 1~999999999. If the locus is a dominant marker, then only one (instead of 2) column is required for the marker, and the value for the genotype should be either 1 (dominant phenotype, presence of a band) or 2 (recessive phenotype, absence of a band). Missing genotypes are indicated by 0 0 for a codominant marker and 0 for a dominant marker."  Also, there cannot be any NA values in the Colony genotype data. 

I wanted to use the R program `radiator` to create a Colony formatted genotype file. But after a TON of attempts I wasn't able to get my SNPRelate .gds data into radiator directly nor could I successfully import a .vcf file. 

So, here I manually re-code the genotype matrix. 

```{r}
# Extract genotype matrix 
geno.matrix4Colony <- snpgdsGetGeno(gdsobj="../qc-processing/colony/genotypes-adult-4Colony.gds", with.id=TRUE)

paste("No. of adult SNPs for Colony sibship analysis: ", ncol(geno.matrix4Colony$genotype), sep="") 
paste("No. of adult samples for Colony sibship analysis: ", nrow(geno.matrix4Colony$genotype), sep="") 

# Replace SNPRelate numeric allele coding with character allele coding 
a <- geno.matrix4Colony$genotype %>% as_data_frame() %>% 
  mutate_all(funs(str_replace(., "0", "BB"))) %>%
  mutate_all(funs(str_replace(., "1", "AB"))) %>%
  mutate_all(funs(str_replace(., "2", "AA")))

# Duplicate each column. Now there's 2 columns per locus, both containing the same bi-allelic genotype info. 
b <- a[rep(names(a), rep(2, times=ncol(a)))] %>% clean_names()
ncol(b) == ncol(a)*2 #should be TRUE 

# For each locus, extract the first allele in column 1, and the second allele in column 2. 
c <- b  #duplicate dataframe 
odds <- seq(from = 1, to = ncol(c), by = 2)
evens <- seq(from = 2, to = ncol(c), by = 2)
odds.names <- colnames(b[odds])
evens.names <- colnames(b[evens])

for (i in 1:length(odds)) {
c[[odds.names[i]]] <- substring(b[[odds.names[i]]], first = 1, last = 1)  
}
for (i in 1:length(evens)) {
c[[evens.names[i]]] <- substring(b[[evens.names[i]]], first = 2, last = 2)  
}

# Now replace the character allele information with Colony's way of numeric coding. 
# There are 2 columns for each locus (e.g. v1 and v1_2), and only 3 options for each allele:
# 1= B allele 
# 2= A allele 
# 0= missing allele 
(geno.matrix4Colony.recode <- c %>% 
  mutate_all(funs(str_replace(., "B", "1"))) %>%
  mutate_all(funs(str_replace(., "A", "2"))) %>%
  mutate(., across(everything(), ~replace_na(.x, 0))))

# Save genotype matrix to file, while also adding a column with sample number 
write_delim(cbind(sampleID=paste("O", geno.matrix4Colony$sample.id, sep=""),
                  geno.matrix4Colony.recode),
            file="../qc-processing/colony/geno.matrix.tab", delim="   ", col_names=FALSE)
```

# Create Colony input file 

I created a text file that will be the input for Colony. I used Colony's example input file to do so. 

Here's a snapshot of the input file, truncating the genotype info (there are 53 samples, but here I only show 2)

```{bash}
head -n 28 ../qc-processing/colony/colony2_adults.dat
tail -n 12 ../qc-processing/colony/colony2_adults.dat
```

# Run Colony analysis on adult samples 

Note: I have to be in the colony directory to run it, so I change my directory in the same code chunk prior to executing the ./colony2s.out script 

```{bash, eval = FALSE}
cd ../qc-processing/colony/
./colony2s.out IFN:colony2_adults.dat
```

```{bash}
cat ../qc-processing/colony/adult_colony.BestCluster
```

```{r}
colony.clusters <- read_table("../qc-processing/colony/adult_colony.BestCluster", col_names=TRUE) %>% clean_names() %>% 
  mutate_all(funs(str_replace(., "\\*|#", ""))) %>%
  mutate(cluster_index=as.numeric(cluster_index), father_id=as.numeric(father_id), mother_id=as.numeric(mother_id), probability=as.numeric(probability)) %>%
  mutate(offspring_id=str_replace(offspring_id, "O", "")) %>% as.data.frame() %>% left_join(sample.info, by = c("offspring_id"="sample"))

save(colony.clusters, file = "../qc-processing/colony/best-cluster-adult")  

# Plot mother ~ father ID 
#ggplotly(
  ggplot(colony.clusters, aes(x=father_id, y=mother_id, size=probability, colour=population, shape=Treatment)) + geom_jitter() + theme_minimal() + scale_shape_manual(values=c(1,2)) + scale_size_continuous(guide="none") #)

# How many fathers and mothers does each population + pCO2 group have? 
colony.clusters %>%
  group_by(population, Treatment) %>%
  summarise(n_fathers=n_distinct(father_id),n_mothers=n_distinct(mother_id)) 
  
# How many fathers and mothers does each population have
colony.clusters %>%
  group_by(population) %>%
  summarise(n_fathers=n_distinct(father_id),n_mothers=n_distinct(mother_id)) 
```


## Larval Sibship analysis via Colony 

```{r}
snpset.larvae.4Colony <- snpgdsLDpruning(genofile.larvae, maf=.2, missing.rate=0.15, autosome.only=FALSE)
snpset.larvae.id.4Colony <- unlist(unname(snpset.larvae.4Colony))
snpgdsCreateGenoSet(src.fn="../qc-processing/gatk/genotypes-larvae.gds",
                    dest.fn="../qc-processing/colony/genotypes-larvae-4Colony.gds",
                    snp.id=snpset.larvae.id.4Colony)
```

## Recode genotypes for Colony 

```{r}
# Extract genotype matrix 
geno.matrix4Colony.larvae <- snpgdsGetGeno(gdsobj="../qc-processing/colony/genotypes-larvae-4Colony.gds", with.id=TRUE)

paste("No. of larvae SNPs for Colony sibship analysis: ", ncol(geno.matrix4Colony.larvae$genotype), sep="") 
paste("No. of larvae samples for Colony sibship analysis: ", nrow(geno.matrix4Colony.larvae$genotype), sep="") 

# Replace SNPRelate numeric allele coding with character allele coding 
a <- geno.matrix4Colony.larvae$genotype %>% as_data_frame() %>% 
  mutate_all(funs(str_replace(., "0", "BB"))) %>%
  mutate_all(funs(str_replace(., "1", "AB"))) %>%
  mutate_all(funs(str_replace(., "2", "AA")))

# Duplicate each column. Now there's 2 columns per locus, both containing the same bi-allelic genotype info. 
b <- a[rep(names(a), rep(2, times=ncol(a)))] %>% clean_names()
ncol(b) == ncol(a)*2 #should be TRUE 

# For each locus, extract the first allele in column 1, and the second allele in column 2. 
c <- b  #duplicate dataframe 
odds <- seq(from = 1, to = ncol(c), by = 2)
evens <- seq(from = 2, to = ncol(c), by = 2)
odds.names <- colnames(b[odds])
evens.names <- colnames(b[evens])

for (i in 1:length(odds.names)) {
c[[odds.names[i]]] <- substring(b[[odds.names[i]]], first = 1, last = 1)  
}
for (i in 1:length(evens.names)) {
c[[evens.names[i]]] <- substring(b[[evens.names[i]]], first = 2, last = 2)  
}

# Now replace the character allele information with Colony's way of numeric coding. 
# There are 2 columns for each locus (e.g. v1 and v1_2), and only 3 options for each allele:
# 1= B allele 
# 2= A allele 
# 0= missing allele 
(geno.matrix4Colony.larvae.recode <- c %>% 
  mutate_all(funs(str_replace(., "B", "1"))) %>%
  mutate_all(funs(str_replace(., "A", "2"))) %>%
  mutate(., across(everything(), ~replace_na(.x, 0))))

# Save genotype matrix to file, while also adding a column with sample number 
write_delim(cbind(sampleID=paste("O", geno.matrix4Colony.larvae$sample.id, sep=""),
                  geno.matrix4Colony.larvae.recode),
            file="../qc-processing/colony/geno.matrix.larvae.tab", delim="   ", col_names=FALSE)
```

# Create Colony input file 

I created a text file that will be the input for Colony. I used Colony's example input file as template and edited by hand. For the genotype matrix I selected all contents in the "geno.matrix.larvae.tab" file and pasted it into the text file. 

Here's a snapshot of the input file, truncating the genotype info (there are 76 samples, but here I only show 4)

```{bash}
head -n 30 ../qc-processing/colony/colony2_larvae.dat
tail -n 12 ../qc-processing/colony/colony2_larvae.dat
```

# Run Colony analysis on larvae samples 

Note: I have to be in the colony directory to run it, so I change my directory in the same code chunk prior to executing the ./colony2s.out script 

```{bash, eval = FALSE}
cd ../qc-processing/colony/
./colony2s.out IFN:colony2_larvae.dat
```

```{bash}
cat ../qc-processing/colony/larvae_colony.BestCluster
```

```{r}
(colony.clusters.larvae <- read_table("../qc-processing/colony/larvae_colony.BestCluster", col_names=TRUE) %>% clean_names() %>% 
  mutate_all(funs(str_replace(., "\\*|#", ""))) %>%
  mutate(cluster_index=as.numeric(cluster_index), father_id=as.numeric(father_id), mother_id=as.numeric(mother_id), probability=as.numeric(probability)) %>%
  mutate(offspring_id=str_replace(offspring_id, "O", "")) %>% as.data.frame() %>% left_join(sample.info.larvae, by = c("offspring_id"="sample")))

save(colony.clusters.larvae, file = "../qc-processing/colony/best-cluster-larvae")  

# Plot mother ~ father ID 
ggplotly(
  ggplot(colony.clusters.larvae, aes(x=father_id, y=mother_id, size=probability, colour=population, shape=Treatment)) + geom_jitter() + theme_minimal() + scale_shape_manual(values=c(1,2)) + scale_size_continuous(guide="none"))

# How many fathers and mothers does each population + pCO2 group have? 
colony.clusters.larvae %>%
  group_by(population, Treatment) %>%
  summarise(n_fathers=n_distinct(father_id),n_mothers=n_distinct(mother_id)) %>%
  pivot_longer(names_to = "parent", values_to="n_parents", cols = c(n_fathers, n_mothers)) %>% 
  mutate(population=as.factor(population),Treatment=as.factor(Treatment),parent=as.factor(parent)) %>%
  ggplot(aes(fill=population, alpha=Treatment, x=population, y=n_parents)) + geom_bar(position="dodge", stat="identity") +
  scale_alpha_discrete(range = c(0.35, 0.8)) + ylab("No. of parents") + 
  facet_wrap(~parent) + theme_minimal() + theme(axis.text.x = element_blank()) + xlab("Population & parental pCO2 exposure")
```

## Juvenile Sibship analysis via Colony 

```{r}
snpset.juvenile.4Colony <- snpgdsLDpruning(genofile.juvenile, maf=.4, missing.rate=0, autosome.only=FALSE)
snpset.juvenile.id.4Colony <- unlist(unname(snpset.juvenile.4Colony))
snpgdsCreateGenoSet(src.fn="../qc-processing/gatk/genotypes-juvenile.gds",
                    dest.fn="../qc-processing/colony/genotypes-juvenile-4Colony.gds",
                    snp.id=snpset.juvenile.id.4Colony)
```

## Recode genotypes for Colony 

```{r}
# Extract genotype matrix 
geno.matrix4Colony.juvenile <- snpgdsGetGeno(gdsobj="../qc-processing/colony/genotypes-juvenile-4Colony.gds", with.id=TRUE)

paste("No. of juvenile SNPs for Colony sibship analysis: ", ncol(geno.matrix4Colony.juvenile$genotype), sep="") 
paste("No. of juvenile samples for Colony sibship analysis: ", nrow(geno.matrix4Colony.juvenile$genotype), sep="") 

# Replace SNPRelate numeric allele coding with character allele coding 
a <- geno.matrix4Colony.juvenile$genotype %>% as_data_frame() %>% 
  mutate_all(funs(str_replace(., "0", "BB"))) %>%
  mutate_all(funs(str_replace(., "1", "AB"))) %>%
  mutate_all(funs(str_replace(., "2", "AA")))

# Duplicate each column. Now there's 2 columns per locus, both containing the same bi-allelic genotype info. 
b <- a[rep(names(a), rep(2, times=ncol(a)))] %>% clean_names()
ncol(b) == ncol(a)*2 #should be TRUE 

# For each locus, extract the first allele in column 1, and the second allele in column 2. 
c <- b  #duplicate dataframe 
odds <- seq(from = 1, to = ncol(c), by = 2)
evens <- seq(from = 2, to = ncol(c), by = 2)
odds.names <- colnames(b[odds])
evens.names <- colnames(b[evens])

for (i in 1:length(odds.names)) {
c[[odds.names[i]]] <- substring(b[[odds.names[i]]], first = 1, last = 1)  
}
for (i in 1:length(evens.names)) {
c[[evens.names[i]]] <- substring(b[[evens.names[i]]], first = 2, last = 2)  
}

# Now replace the character allele information with Colony's way of numeric coding. 
# There are 2 columns for each locus (e.g. v1 and v1_2), and only 3 options for each allele:
# 1= B allele 
# 2= A allele 
# 0= missing allele 
(geno.matrix4Colony.juvenile.recode <- c %>% 
  mutate_all(funs(str_replace(., "B", "1"))) %>%
  mutate_all(funs(str_replace(., "A", "2"))) %>%
  mutate(., across(everything(), ~replace_na(.x, 0))))

# Save genotype matrix to file, while also adding a column with sample number 
write_delim(cbind(sampleID=paste("O", geno.matrix4Colony.juvenile$sample.id, sep=""),
                  geno.matrix4Colony.juvenile.recode),
            file="../qc-processing/colony/geno.matrix.juvenile.tab", delim="   ", col_names=FALSE)
```

# Create Colony input file 

I created a text file that will be the input for Colony. I used Colony's example input file as template and edited by hand. For the genotype matrix I selected all contents in the "geno.matrix.juvenile.tab" file and pasted it into the text file. 

Here's a snapshot of the input file, truncating the genotype info (there are 16 samples, but here I only show 1)

```{bash}
head -n 28 ../qc-processing/colony/colony2_juveniles.dat
tail -n 12 ../qc-processing/colony/colony2_juveniles.dat
```

# Run Colony analysis on juvenile samples 

Note: I have to be in the colony directory to run it, so I change my directory in the same code chunk prior to executing the ./colony2s.out script 

```{bash, eval = FALSE}
cd ../qc-processing/colony/
./colony2s.out IFN:colony2_juveniles.dat
```

```{bash}
cat ../qc-processing/colony/juvenile_colony.BestCluster
```

```{r}
(colony.clusters.juvenile <- read_table("../qc-processing/colony/juvenile_colony.BestCluster", col_names=TRUE) %>% clean_names() %>% 
  mutate_all(funs(str_replace(., "\\*|#", ""))) %>%
  mutate(cluster_index=as.numeric(cluster_index), father_id=as.numeric(father_id), mother_id=as.numeric(mother_id), probability=as.numeric(probability)) %>%
  mutate(offspring_id=str_replace(offspring_id, "O", "")) %>% as.data.frame() %>% left_join(sample.info.juvenile, by = c("offspring_id"="sample")))

save(colony.clusters.juvenile, file = "../qc-processing/colony/best-cluster-juvenile")  

# Plot mother ~ father ID 
ggplotly(
  ggplot(colony.clusters.juvenile, aes(x=father_id, y=mother_id, size=probability, colour=population, shape=Treatment)) + geom_jitter() + theme_minimal() + scale_shape_manual(values=c(1,2)) + scale_size_continuous(guide="none"))

# How many fathers and mothers does each population + pCO2 group have? 
colony.clusters.juvenile %>%
  group_by(population, Treatment) %>%
  summarise(n_fathers=n_distinct(father_id),n_mothers=n_distinct(mother_id)) %>%
  pivot_longer(names_to = "parent", values_to="n_parents", cols = c(n_fathers, n_mothers)) %>% 
  mutate(population=as.factor(population),Treatment=as.factor(Treatment),parent=as.factor(parent)) %>%
  ggplot(aes(fill=population, alpha=Treatment, x=population, y=n_parents)) + geom_bar(position="dodge", stat="identity") +
  scale_alpha_discrete(range = c(0.35, 0.8)) + ylab("No. of parents") + 
  facet_wrap(~parent) + theme_minimal() + theme(axis.text.x = element_blank()) + xlab("Population & parental pCO2 exposure")
```
