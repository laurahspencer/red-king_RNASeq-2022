---
title: "04_GO-enrichment"
author: "Laura H Spencer"
date: "3/22/2022"
output: html_document
---

```{r}
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("GSEABase")

require(ggpubr)
require(tidyverse)
require(GSEABase)
require(ape)
```

In this notebook I use GO_MWU to perform a gene ontology enrichment analysis for gene sets of interest, which include 1) Differentially expressed genes (DEGs) derived from DESeq2, and 2) Modules of genes associated with pH, derived from WGCNA. The input files for each of the gene sets were generated in the DESeq2 and WGCNA notebooks. 

This notebook contains code from the GO_MWU program. 

```{r}
setwd("~/red-king_RNASeq-2022/results/GO_MWU")
```

```{r}
getwd()
```

```{r}
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
source("gomwu.functions.R")
```

Create a list of GO devisions, Biological Processes (BP), Molecular Functions (MF), Cellular Components (CC), to loop over 

```{r}
goDivisions <- c("BP", "MF", "CC")
```

# NOTE:  I write separate GO_MWU functions for the DEG lists and the WGCNA module lists. This is because GO_MWU has different settings for those two types of analyses. 

# Identify enriched functions in genes differentially expressed among pH treatments (from DESeq2)

## Create a GO_MWU function for enrichment analysis of DEGs 

```{r}
log(0.05, base = 10)
```
Create an empty list in which to save the best GO terms from each enrichment analysis. This list consitutes GO terms that best represent *independent* groups of significant GO terms

```{r}
best_GO <- list()
```

```{r}
go.mwu.degs <- function(contrast) {
  
  input = paste("DEGs_", contrast, ".csv", sep="")
  goAnnotations = "DESeq-genes_for-GOMWU.tab"

for (j in 1:length(goDivisions)) {
  tryCatch({
  
# ------------- Calculating stats
# It might take a few minutes for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.

gomwuStats(input, goDatabase, goAnnotations, goDivisions[j],
	perlPath="C:/Strawberry/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
	smallest=5,   # a GO category should contain at least this many genes to be considered
	clusterCutHeight=0.30, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
	#Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.


# ----------- Plotting results

#quartz()
pdf(file = paste("GO-tree_", contrast, "_", goDivisions[j], ".pdf", sep=""), height = length(results[[2]]$labels)/3)
results=gomwuPlot(input,goAnnotations,goDivisions[j],
 	#absValue=-log(0.05,10),   # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
 absValue=.5, # un-remark this if you are using log2-fold changes
 level1=0.05,level2=0.01,level3=0.001,	#stricter settings for many GO terms 
 #level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
 	#level2=0.05, # FDR cutoff to print in regular (not italic) font.
 	#level3=0.01, # FDR cutoff to print in large bold font.
 	txtsize=1,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
 	treeHeight=0.5, # height of the hierarchical clustering tree
 	#colors=c(color, color, color, color, color)
 colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
 )
mtext(paste(contrast, " - ", goDivisions[j], sep=""), side = 3, line = 3, adj = -.05, col="black")
dev.off()
 # manually rescale the plot so the tree matches the text 
 # if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.  
 
 # text representation of results, with actual adjusted p-values
 print(results[[1]])


# ------- extracting representative GOs

# this module chooses GO terms that best represent *independent* groups of significant GO terms

pcut=1e-2 # adjusted pvalue cutoff for representative GO
hcut=0.9 # height at which cut the GO terms tree to get "independent groups". 

# plotting the GO tree with the cut level (un-remark the next two lines to plot)
# plot(results[[2]],cex=0.6)
# abline(h=hcut,col="red")

# cutting
ct=cutree(results[[2]],h=hcut)
annots=c();ci=1
for (ci in unique(ct)) {
  message(ci)
	rn=names(ct)[ct==ci]
	obs=grep("obsolete",rn)
	if(length(obs)>0) { rn=rn[-obs] }
	if (length(rn)==0) {next}
	rr=results[[1]][rn,]
	bestrr=rr[which(rr$pval==min(rr$pval)),]
	best=1
	if(nrow(bestrr)>1) {
		nns=sub(" .+","",row.names(bestrr))
		fr=c()
		for (i in 1:length(nns)) { fr=c(fr,eval(parse(text=nns[i]))) }
		best=which(fr==max(fr))
	}
	if (bestrr$pval[best]<=pcut) { annots=c(annots,sub("\\d+\\/\\d+ ","",row.names(bestrr)[best]))}
}

mwus=read.table(paste("MWU",goDivisions[j],input,sep="_"),header=T)
bestGOs=mwus[mwus$name %in% annots,]
print(bestGOs)

# Save best go terms to list for use outside of function
best_GO[[paste(contrast, goDivisions[j], sep="_")]] <<- bestGOs 
},
error=function(e){cat("ERROR:", conditionMessage(e), "\n")})
}
}
```


# NOTE: in dendrograms, RED=upregulated, BLUE=downregulated 

## DEGs between ambient conditions (pH ~8.0) and moderate OA (pH ~7.8)

```{r}
go.mwu.degs(contrast="amb-mod")
```

```{r}
best_GO$`amb-mod_BP`
```


## DEGs between ambient conditions (pH ~8.0) and severe OA (pH ~7.5)

```{r}
go.mwu.degs(contrast="amb-low")
```

## DEGs between moderate conditions (pH ~8.0) and severe OA (pH ~7.5)

```{r}
go.mwu.degs(contrast="mod-low")
```

# Identify enriched functions in genes within modules that are signficantly associated with pH (from WGCNA) 

The "color" argument refers to the color for each GO tree (so for some modules, it's best to make that a slightly different color)

```{r}
go.mwu.wgcna <- function(module, color) {
  
  input=paste("WGCNA-module_", module, ".csv", sep="") # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
  
  goAnnotations.wgcna="WGCNA-genes_for-GOMWU.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.

for (j in 1:length(goDivisions)) {
  tryCatch({
  
# ------------- Calculating stats
# It might take a few minutes for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.

    gomwuStats(input, goDatabase, goAnnotations.wgcna, goDivisions[j],
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
	smallest=5,   # a GO category should contain at least this many genes to be considered
	clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.

# ----------- Plotting results

#quartz()
results=gomwuPlot(input,goAnnotations.wgcna,goDivisions[j],
 	absValue=0.001,  #-log(0.05,10) # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
 #	absValue=1, # un-remark this if you are using log2-fold changes
 	level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
 	level2=0.05, # FDR cutoff to print in regular (not italic) font.
 	level3=0.01, # FDR cutoff to print in large bold font.
 	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
 	treeHeight=0.5, # height of the hierarchical clustering tree
 	#colors=c(color, color, color, color, color)
 colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
 )
mtext(paste(module, "-", goDivisions[j], sep=""), side = 3, line = .25, adj = 0, col=color) #module
 # manually rescale the plot so the tree matches the text 
 # if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.  
 
 # text representation of results, with actual adjusted p-values
 print(results[[1]])


# ------- extracting representative GOs
# this module chooses GO terms that best represent *independent* groups of significant GO terms

pcut=1e-2 # adjusted pvalue cutoff for representative GO
hcut=0.9 # height at which cut the GO terms tree to get "independent groups". 

# plotting the GO tree with the cut level (un-remark the next two lines to plot)
# plot(results[[2]],cex=0.6)
# abline(h=hcut,col="red")

# cutting
ct=cutree(results[[2]],h=hcut)
annots=c();ci=1
for (ci in unique(ct)) {
  message(ci)
	rn=names(ct)[ct==ci]
	obs=grep("obsolete",rn)
	if(length(obs)>0) { rn=rn[-obs] }
	if (length(rn)==0) {next}
	rr=results[[1]][rn,]
	bestrr=rr[which(rr$pval==min(rr$pval)),]
	best=1
	if(nrow(bestrr)>1) {
		nns=sub(" .+","",row.names(bestrr))
		fr=c()
		for (i in 1:length(nns)) { fr=c(fr,eval(parse(text=nns[i]))) }
		best=which(fr==max(fr))
	}
	if (bestrr$pval[best]<=pcut) { annots=c(annots,sub("\\d+\\/\\d+ ","",row.names(bestrr)[best]))}
}

mwus=read.table(paste("MWU",goDivisions[j],input,sep="_"),header=T)
bestGOs=mwus[mwus$name %in% annots,]
print(bestGOs)
},
error=function(e){cat("ERROR:", conditionMessage(e), "\n")})
}
}
```

# pH-associated modules 
```{r}
load(file="../wgcna/modules")
modules
```


This is the list of modules that are associated with pH 
```{r}
load(file = "../wgcna/module.lineplots") #load lineplots to plot alongside enrichment to aid in interpretation 
```

# TO DO - FIGURE OUT HOW TO GO GO_MWU USING THE GS DATA! 

## Module == `modules[[1]]`

```{r}
module.lineplots[[1]]

go.mwu.wgcna(module = modules[[1]], color = modules[[1]])
#go.mwu.wgcna(module = "brown", color = "darkgoldenrod4")
```

## Module == Pink 
## Module == `modules[[2]]`

```{r}
module.lineplots[[2]]
#module.lineplots[["pink"]]

go.mwu.wgcna(module = modules[[2]], color = modules[[2]])
```

## Module == red 
## Module == `modules[[3]]`

```{r}
module.lineplots[[3]]

go.mwu.wgcna(module=modules[[3]], modules[[3]])
```

## Module == cyan 
## Module == `modules[[4]]`

```{r}
#module.lineplots[["cyan"]]
module.lineplots[[4]]
go.mwu.wgcna(module=modules[[4]], color=modules[[4]])
```

## Module == green 
## Module == `modules[[5]]`

```{r}
#module.lineplots[["green"]]
module.lineplots[[5]]
go.mwu.wgcna(module=modules[[5]], color=modules[[5]])
```

## Module == darkgreen 
## Module == `modules[[6]]`

```{r}
module.lineplots[[6]]
go.mwu.wgcna(module=modules[[6]], color=modules[[6]])
```

## Module == lightcyan1 
## Module == `modules[[7]]`

```{r}
#module.lineplots[[7]]
#go.mwu.wgcna(module=modules[[7]], color=modules[[7]])
```

## WGCNA modules that increase or decrease in moderate compared to ambient & low 

These modules were hand-selected based on line plots 

```{r}
load(file = "../wgcna/modules.all.lineplots")
```

## Module == mediumpurple3 

Lower in moderate OA

```{r}
# modules.all.lineplots[["mediumpurple3"]]
# go.mwu.wgcna(module="mediumpurple3", color="mediumpurple3")
```

## Module == saddlebrown 

Higher in moderate OA 

```{r}
# modules.all.lineplots[["saddlebrown"]]
# go.mwu.wgcna(module="saddlebrown", color="saddlebrown")
```

# Import GO_MWU results spreadsheets 
```{r}
read_delim(file="MWU_BP_WGCNA-module_cyan.csv",delim = " ") %>% mutate(module="cyan") %>% filter(p.adj<0.05)
```
```{r}
getwd()
```


```{bash}
## Remove files which list GO_MWU results filenames if they already exist  
rm BP_filenames.txt
rm MF_filenames.txt
rm CC_filenames.txt

for file in MWU_BP*
do
filename="$(echo $file)"
sample="$(basename -a $filename | cut -d "_" -f 4  | cut -d "." -f 1)"
printf "%s\t%s\n" "$filename" "$sample" >> BP_filenames.txt
done

# Molecular functions results 
for file in MWU_MF*
do
filename="$(echo $file)"
sample="$(basename -a $filename | cut -d "_" -f 4  | cut -d "." -f 1)"
printf "%s\t%s\n" "$filename" "$sample" >> MF_filenames.txt
done

# Cellular components results 
for file in MWU_CC*
do
filename="$(echo $file)"
sample="$(basename -a $filename | cut -d "_" -f 4  | cut -d "." -f 1)"
printf "%s\t%s\n" "$filename" "$sample" >> CC_filenames.txt
done
```

```{r}
modules
```

## Read in enriched Biological Processes 

```{r}
filenames <- read_delim(file="BP_filenames.txt", col_names = c("filename", "gene_set"))
files <- file.path(filenames$filename) #extract vector of filenames 
all(file.exists(files)) #easy code to check that all files exist! 

file_list <- vector(mode = "list", length = nrow(filenames))
names(file_list) <- c(filenames$gene_set)

for (i in 1:nrow(filenames)) {
    file_list[[i]] <- data.frame(read_delim(file=files[i], delim = " "))}

(gene_sets.BP <- bind_rows(file_list, .id = "gene_set") %>% filter(p.adj<0.05) %>%  # Bind dataframe for each gene_set together
    mutate(category=as.factor("Biological Processes")) %>%  #add column designating go category 
    mutate(gene_set=factor(gene_set, levels=c("amb-mod", "amb-low", "mod-low", modules))) %>% #Convert gene_set column to factor, define all gene_sets 
    tidyr::complete(gene_set, category) %>% # add rows for gene_sets that are missing from dataframe

    # Create new column that identifies which treatment is upregulated in each DEG contrast (doesn't apply for WGCNA modules)
    mutate(gene_set_up = case_when((gene_set == "amb-mod" & delta.rank < 0) ~ "Ambient",
                                      (gene_set == "amb-mod" & delta.rank > 0) ~ "Moderate",
                                        (gene_set == "amb-low" & delta.rank < 0) ~ "Ambient",
                                        (gene_set == "amb-low" & delta.rank > 0) ~ "Low",
                                        (gene_set == "mod-low" & delta.rank < 0) ~ "Moderate",
                                        (gene_set == "mod-low" & delta.rank > 0) ~ "Moderate",
                                        gene_set == "cyan" ~ "cyan",
                                        gene_set == "pink" ~ "pink",
                                        gene_set == "brown" ~ "brown",
                                        gene_set == "lightcyan1" ~ "lightcyan1",
                                        gene_set == "darkgreen" ~ "darkgreen",
                                        gene_set == "green" ~ "green")))  

```

## Read in enriched Molecular Functions

```{r}
filenames <- read_delim(file="MF_filenames.txt", col_names = c("filename", "gene_set"))
files <- file.path(filenames$filename) #extract vector of filenames 
all(file.exists(files)) #easy code to check that all files exist! 

file_list <- vector(mode = "list", length = nrow(filenames))
names(file_list) <- c(filenames$gene_set)

for (i in 1:nrow(filenames)) {
    file_list[[i]] <- data.frame(read_delim(file=files[i], delim = " "))}

(gene_sets.MF <- bind_rows(file_list, .id = "gene_set") %>% filter(p.adj<0.05) %>%  # Bind dataframe for each gene_set together
    mutate(category=as.factor("Molecular Functions")) %>%  #add column designating go category 
    mutate(gene_set=factor(gene_set, levels=c("amb-mod", "amb-low", "mod-low", modules))) %>% #Convert gene_set column to factor, define all gene_sets 
    tidyr::complete(gene_set, category) %>% # add rows for gene_sets that are missing from dataframe

    # Create new column that identifies which treatment is upregulated in each DEG contrast (doesn't apply for WGCNA modules)
    mutate(gene_set_up = case_when((gene_set == "amb-mod" & delta.rank < 0) ~ "Ambient",
                                      (gene_set == "amb-mod" & delta.rank > 0) ~ "Moderate",
                                        (gene_set == "amb-low" & delta.rank < 0) ~ "Ambient",
                                        (gene_set == "amb-low" & delta.rank > 0) ~ "Low",
                                        (gene_set == "mod-low" & delta.rank < 0) ~ "Moderate",
                                        (gene_set == "mod-low" & delta.rank > 0) ~ "Moderate",
                                        gene_set == "cyan" ~ "cyan",
                                        gene_set == "pink" ~ "pink",
                                        gene_set == "brown" ~ "brown",
                                        gene_set == "lightcyan1" ~ "lightcyan1",
                                        gene_set == "darkgreen" ~ "darkgreen",
                                        gene_set == "green" ~ "green")))  
```

## Read in enriched Cellular Componenets  

```{r}
filenames <- read_delim(file="CC_filenames.txt", col_names = c("filename", "gene_set"))
files <- file.path(filenames$filename) #extract vector of filenames 
all(file.exists(files)) #easy code to check that all files exist! 

file_list <- vector(mode = "list", length = nrow(filenames))
names(file_list) <- c(filenames$gene_set)

for (i in 1:nrow(filenames)) {
    file_list[[i]] <- data.frame(read_delim(file=files[i], delim = " "))}

(gene_sets.CC <- bind_rows(file_list, .id = "gene_set") %>% filter(p.adj<0.05) %>%  # Bind dataframe for each gene_set together
    mutate(category=as.factor("Cellular Components")) %>%  #add column designating go category 
    mutate(gene_set=factor(gene_set, levels=c("amb-mod", "amb-low", "mod-low", modules))) %>% #Convert gene_set column to factor, define all gene_sets 
    tidyr::complete(gene_set, category) %>% # add rows for gene_sets that are missing from dataframe

    # Create new column that identifies which treatment is upregulated in each DEG contrast (doesn't apply for WGCNA modules)
    mutate(gene_set_up = case_when((gene_set == "amb-mod" & delta.rank < 0) ~ "Ambient",
                                      (gene_set == "amb-mod" & delta.rank > 0) ~ "Moderate",
                                        (gene_set == "amb-low" & delta.rank < 0) ~ "Ambient",
                                        (gene_set == "amb-low" & delta.rank > 0) ~ "Low",
                                        (gene_set == "mod-low" & delta.rank < 0) ~ "Moderate",
                                        (gene_set == "mod-low" & delta.rank > 0) ~ "Moderate",
                                        gene_set == "cyan" ~ "cyan",
                                        gene_set == "pink" ~ "pink",
                                        gene_set == "brown" ~ "brown",
                                        gene_set == "lightcyan1" ~ "lightcyan1",
                                        gene_set == "darkgreen" ~ "darkgreen",
                                        gene_set == "green" ~ "green")))  
```

```{r}
paste("No. of BP enriched in Amb vs Mod = ", gene_sets.BP %>% filter(gene_set=="amb-mod") %>% nrow())
paste("No. of BP enriched in Amb vs Low = ", gene_sets.BP %>% filter(gene_set=="amb-low") %>% nrow())
paste("No. of BP enriched in Mod vs Low = ", gene_sets.BP %>% filter(gene_set=="mod-low") %>% nrow())

paste("No. of MF enriched in Amb vs Mod = ", gene_sets.MF %>% filter(gene_set=="amb-mod") %>% nrow())
paste("No. of MF enriched in Amb vs Low = ", gene_sets.MF %>% filter(gene_set=="amb-low") %>% nrow())
paste("No. of MF enriched in Mod vs Low = ", gene_sets.MF %>% filter(gene_set=="mod-low") %>% nrow())

paste("No. of CC enriched in Amb vs Mod = ", gene_sets.CC %>% filter(gene_set=="amb-mod") %>% nrow())
paste("No. of CC enriched in Amb vs Low = ", gene_sets.CC %>% filter(gene_set=="amb-low") %>% nrow())
paste("No. of CC enriched in Mod vs Low = ", gene_sets.CC %>% filter(gene_set=="mod-low") %>% nrow())
```

```{r}
gene_sets.BP %>% filter(gene_set=="amb-mod") %>% dplyr::select(name) %>% write_clip()
gene_sets.BP %>% filter(gene_set=="amb-low") %>% dplyr::select(name) %>% write_clip()
gene_sets.BP %>% filter(gene_set=="mod-low") %>% dplyr::select(name) %>% write_clip()
```


## Bubble plot- enriched Biological Processes by module 

The column "gene_set_up" denotes the up/down for the DEG contrasts (it is zero for WGCNA modules)

```{r}
# Plot enriched Biological Processes 
pdf(file="Enriched_BP.pdf", height = 7, width = 7.5)
ggplot(gene_sets.BP, aes(y=str_wrap(name),x=gene_set, col=gene_set_up)) + 
  geom_point(aes(alpha=p.adj,size=nseqs))+
 facet_wrap(~category,scales="free", nrow = 2) +
  scale_alpha("FDR-adjusted\nP-value", range = c(1,0.35), #breaks = c(0, .25, .5, .75, 1), 
              guide = guide_legend(override.aes = list(size=4))) + 
  scale_size("Gene count", range = c(3,8), #breaks = c(2, 5, 10), 
             guide = guide_legend(override.aes = list(col="gray50"))) + 
  scale_color_manual(name="Upregulated", breaks=c("Ambient", "Moderate", "Low"), 
                     values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c",
                                                  cyan="cyan", pink="pink", brown="brown", 
                                                  lightcyan1="lightcyan1", darkgreen="darkgreen", green="green"),
             guide = guide_legend(override.aes = list(size=4))) +
  scale_x_discrete(drop=FALSE) +
  theme_cleveland() + 
  theme(axis.title.x=element_blank(), 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        #axis.ticks.x = element_blank(), 
        legend.position = "right", axis.text.y=element_text(size=7.25), 
        plot.title = element_text(size=10)) +
  ylab("Enriched Gene Ontology (GO) Term") + 
  ggtitle("Enriched Biological Processes in gene sets") +
  geom_vline(xintercept = c(3.5), colour="gray50", linetype="dashed") #+
  # geom_vline(xintercept = c(1.5,2.5,3.5,4.5,5.5,7.5), colour="gray50", linetype="dashed") 
  # annotate("text", x = 1.4, y = -.75, label = "Dabob Bay\nvs. Fidalgo Bay", size=2.8, col="gray15") +  
  # annotate("text", x = 3.5, y = -.75, label = "Dabob Bay\nvs. Oyster Bay", size=2.8, col="gray15") +  
  # annotate("text", x = 5.6, y = -.75, label = "Fidalgo Bay\nvs. Oyster Bay", size=2.8, col="gray15") +  
  # coord_cartesian(clip = "off", ylim = c(-1.75, 63.5))
dev.off()
```

```{r}
# Plot enriched Molecular Functions
pdf(file="Enriched_MF.pdf", height = 14, width = 7.5)
ggplot(gene_sets.MF, aes(y=str_wrap(name),x=gene_set, col=gene_set_up)) + 
  geom_point(aes(alpha=p.adj,size=nseqs))+
 facet_wrap(~category,scales="free", nrow = 2) +
  scale_alpha("FDR-adjusted\nP-value", range = c(1,0.35), #breaks = c(0, .25, .5, .75, 1), 
              guide = guide_legend(override.aes = list(size=4))) + 
  scale_size("Gene count", range = c(3,8), #breaks = c(2, 5, 10), 
             guide = guide_legend(override.aes = list(col="gray50"))) + 
  scale_color_manual(name="Upregulated", breaks=c("Ambient", "Moderate", "Low"), 
                     values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c",
                                                  cyan="cyan", pink="pink", brown="brown", 
                                                  lightcyan1="lightcyan1", darkgreen="darkgreen", green="green"),
             guide = guide_legend(override.aes = list(size=4))) +
  scale_x_discrete(drop=FALSE) +
  theme_cleveland() + 
  theme(axis.title.x=element_blank(), 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        #axis.ticks.x = element_blank(), 
        legend.position = "right", axis.text.y=element_text(size=7.25), 
        plot.title = element_text(size=10)) +
  ylab("Enriched Gene Ontology (GO) Term") + 
  ggtitle("Enriched Molecular Functions in gene sets") +
  geom_vline(xintercept = c(3.5), colour="gray50", linetype="dashed") #+
  # geom_vline(xintercept = c(1.5,2.5,3.5,4.5,5.5,7.5), colour="gray50", linetype="dashed") 
  # annotate("text", x = 1.4, y = -.75, label = "Dabob Bay\nvs. Fidalgo Bay", size=2.8, col="gray15") +  
  # annotate("text", x = 3.5, y = -.75, label = "Dabob Bay\nvs. Oyster Bay", size=2.8, col="gray15") +  
  # annotate("text", x = 5.6, y = -.75, label = "Fidalgo Bay\nvs. Oyster Bay", size=2.8, col="gray15") +  
  # coord_cartesian(clip = "off", ylim = c(-1.75, 63.5))
dev.off()
```

```{r}
# Plot enriched Cellular Components
pdf(file="Enriched_CC.pdf", height = 4.5, width = 5.5)

ggplot(gene_sets.CC, aes(y=str_wrap(name),x=gene_set, col=gene_set_up)) + 
  geom_point(aes(alpha=p.adj,size=nseqs))+
 facet_wrap(~category,scales="free", nrow = 2) +
  scale_alpha("FDR-adjusted\nP-value", range = c(1,0.35), #breaks = c(0, .25, .5, .75, 1), 
              guide = guide_legend(override.aes = list(size=4))) + 
  scale_size("Gene count", range = c(3,8), #breaks = c(2, 5, 10), 
             guide = guide_legend(override.aes = list(col="gray50"))) + 
  scale_color_manual(name="Upregulated", breaks=c("Ambient", "Moderate", "Low"), 
                     values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c",
                                                  cyan="cyan", pink="pink", brown="brown", 
                                                  lightcyan1="lightcyan1", darkgreen="darkgreen", green="green"),
             guide = guide_legend(override.aes = list(size=4))) +
  scale_x_discrete(drop=FALSE) +
  theme_cleveland() + 
  theme(axis.title.x=element_blank(), 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        #axis.ticks.x = element_blank(), 
        legend.position = "right", axis.text.y=element_text(size=7.25), 
        plot.title = element_text(size=10)) +
  ylab("Enriched Gene Ontology (GO) Term") + 
  ggtitle("Enriched Cellular Componenets in gene sets") +
  geom_vline(xintercept = c(3.5), colour="gray50", linetype="dashed") #+
  # geom_vline(xintercept = c(1.5,2.5,3.5,4.5,5.5,7.5), colour="gray50", linetype="dashed") 
  # annotate("text", x = 1.4, y = -.75, label = "Dabob Bay\nvs. Fidalgo Bay", size=2.8, col="gray15") +  
  # annotate("text", x = 3.5, y = -.75, label = "Dabob Bay\nvs. Oyster Bay", size=2.8, col="gray15") +  
  # annotate("text", x = 5.6, y = -.75, label = "Fidalgo Bay\nvs. Oyster Bay", size=2.8, col="gray15") +  
  # coord_cartesian(clip = "off", ylim = c(-1.75, 63.5))
dev.off()
```

## ONLY WGCNA bubble plots 

```{r}
# Biological Processes
ggplot(gene_sets.BP %>% filter(gene_set %in% modules) %>% droplevels(), aes(y=str_wrap(name),x=gene_set, col=gene_set)) + 
  geom_point(aes(alpha=p.adj,size=nseqs))+
 facet_wrap(~category,scales="free", nrow = 2) +
  scale_alpha("FDR-adjusted\nP-value", range = c(1,0.35), #breaks = c(0, .25, .5, .75, 1), 
              guide = guide_legend(override.aes = list(size=4))) + 
  scale_size("Gene count", range = c(3,8), #breaks = c(2, 5, 10), 
             guide = guide_legend(override.aes = list(col="gray50"))) + 
  scale_color_manual(name="Gene Set", values=modules,
             guide = guide_legend(override.aes = list(size=4))) +
  scale_x_discrete(drop=FALSE) +
  theme_cleveland() + 
  theme(axis.title.x=element_blank(), 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        #axis.ticks.x = element_blank(), 
        legend.position = "right", axis.text.y=element_text(size=7.25), 
        plot.title = element_text(size=10)) +
  ylab("Enriched Gene Ontology (GO) Term") + 
  ggtitle("Enriched Biological Processes in gene sets")

# Molecular Functions 
ggplot(gene_sets.MF %>% filter(gene_set %in% modules) %>% droplevels(), aes(y=str_wrap(name),x=gene_set, col=gene_set)) + 
  geom_point(aes(alpha=p.adj,size=nseqs))+
 facet_wrap(~category,scales="free", nrow = 2) +
  scale_alpha("FDR-adjusted\nP-value", range = c(1,0.35), #breaks = c(0, .25, .5, .75, 1), 
              guide = guide_legend(override.aes = list(size=4))) + 
  scale_size("Gene count", range = c(3,8), #breaks = c(2, 5, 10), 
             guide = guide_legend(override.aes = list(col="gray50"))) + 
  scale_color_manual(name="Gene Set", values=modules,
             guide = guide_legend(override.aes = list(size=4))) +
  scale_x_discrete(drop=FALSE) +
  theme_cleveland() + 
  theme(axis.title.x=element_blank(), 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        #axis.ticks.x = element_blank(), 
        legend.position = "right", axis.text.y=element_text(size=7.25), 
        plot.title = element_text(size=10)) +
  ylab("Enriched Gene Ontology (GO) Term") + 
  ggtitle("Enriched Molecular Functions in gene sets")

# Cellular components
ggplot(gene_sets.CC %>% filter(gene_set %in% modules) %>% droplevels(), aes(y=str_wrap(name),x=gene_set, col=gene_set)) + 
  geom_point(aes(alpha=p.adj,size=nseqs))+
 facet_wrap(~category,scales="free", nrow = 2) +
  scale_alpha("FDR-adjusted\nP-value", range = c(1,0.35), #breaks = c(0, .25, .5, .75, 1), 
              guide = guide_legend(override.aes = list(size=4))) + 
  scale_size("Gene count", range = c(3,8), #breaks = c(2, 5, 10), 
             guide = guide_legend(override.aes = list(col="gray50"))) + 
  scale_color_manual(name="Gene Set", values=modules,
             guide = guide_legend(override.aes = list(size=4))) +
  scale_x_discrete(drop=FALSE) +
  theme_cleveland() + 
  theme(axis.title.x=element_blank(), 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        #axis.ticks.x = element_blank(), 
        legend.position = "right", axis.text.y=element_text(size=7.25), 
        plot.title = element_text(size=10)) +
  ylab("Enriched Gene Ontology (GO) Term") + 
  ggtitle("Enriched Cellular Componenets in gene sets")
```


```{r}
gene_sets.BP %>% filter(gene_set %!in% modules) %>% droplevels() %>% 
         filter(name %in% unique(c(best_GO$`amb-mod_BP`$name, best_GO$`amb-low_BP`$name, best_GO$`mod-low_BP`$name))) %>% 
         mutate(name=as.factor(name)) %>% mutate(name=fct_reorder(name, delta.rank, .desc = TRUE))


```


## ONLY DEG bubble plots 

```{r}
# Create function that is the oppositve of %in% 
`%!in%` = Negate(`%in%`)

# Biological Processes
#pdf(file="Enriched_BP_DEGs.pdf", height = 13.5, width = 7.5)
ggplot(gene_sets.BP %>% filter(gene_set %!in% modules) %>% droplevels() %>% 
         #filter(p.adj<0.01) %>%
         filter(name %in% unique(c(best_GO$`amb-mod_BP`$name, best_GO$`amb-low_BP`$name, best_GO$`mod-low_BP`$name))) %>%  # use only the best GO terms (determined within GO_MWU ananlysis)
         mutate(name=as.factor(name)) %>% mutate(name=fct_reorder(name, delta.rank, .desc = TRUE)), 
       #aes(y=str_wrap(name),x=gene_set, col=gene_set_up)) + 
       aes(y=name,x=gene_set, col=gene_set_up)) + 
  geom_point(aes(alpha=p.adj, size=nseqs)) + #size=6,  
 facet_wrap(~category,scales="free", nrow = 2) +
  scale_color_manual(name="Upregulated", values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"),
             guide = guide_legend(override.aes = list(size=4))) +
  scale_alpha("FDR-adjusted\nP-value", range = c(1,0.35), #breaks = c(0, .25, .5, .75, 1), 
              guide = guide_legend(override.aes = list(size=4))) + 
  scale_size("Gene count", range = c(3,8), #breaks = c(2, 5, 10),
             guide = guide_legend(override.aes = list(col="gray50"))) +
  scale_x_discrete(drop=FALSE) +
  theme_cleveland() + 
  theme(axis.title.x=element_blank(), 
        axis.text.x = element_blank(), #element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.ticks.x = element_blank(), 
        legend.position = "right", 
        axis.text.y=element_text(size=7.25), 
        plot.title = element_text(size=10),
        legend.text=element_text(size=6), 
        legend.title = element_text(size=6)) +
  ylab("Enriched Gene Ontology (GO) Term") + 
  ggtitle(NULL) +
  annotate("text", x = 1, y = -.25, label = "Ambient\nvs. Moderate", size=2.25, col="gray15") +  
  annotate("text", x = 2, y = -.25, label = "Ambient\nvs. Low", size=2.25, col="gray15") +  
  annotate("text", x = 3, y = -.25, label = "Moderate\nvs. Low", size=2.25, col="gray15") +  
  #coord_cartesian(clip = "off", ylim = c(-0.6, 80))
  coord_cartesian(clip = "off", ylim = c(-0.6, 20))
#dev.off()

# Molecular Functions 
#pdf(file="Enriched_MF_DEGs.pdf", height = 25, width = 7.5)
ggplot(gene_sets.MF %>% filter(gene_set %!in% modules) %>% droplevels() %>% 
          #filter(p.adj<0.01) %>%
           filter(name %in% unique(c(best_GO$`amb-mod_MF`$name, best_GO$`amb-low_MF`$name, best_GO$`mod-low_MF`$name))) %>%  # use only the best GO terms 
         mutate(name=as.factor(name)) %>% mutate(name=fct_reorder(name, delta.rank, .desc = TRUE)),  
#       aes(y=str_wrap(name),x=gene_set, col=gene_set_up)) + 
        aes(y=name,x=gene_set, col=gene_set_up)) + 
  geom_point(aes(alpha=p.adj, size=nseqs)) + #size=6,  
 facet_wrap(~category,scales="free", nrow = 2) +
  scale_color_manual(name="Upregulated", values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"),
             guide = guide_legend(override.aes = list(size=4))) +
  scale_alpha("FDR-adjusted\nP-value", range = c(1,0.35), #breaks = c(0, .25, .5, .75, 1), 
              guide = guide_legend(override.aes = list(size=4))) + 
  scale_size("Gene count", range = c(3,8), #breaks = c(2, 5, 10),
             guide = guide_legend(override.aes = list(col="gray50"))) +
  scale_x_discrete(drop=FALSE) +
  theme_cleveland() + 
  theme(axis.title.x=element_blank(), 
        axis.text.x = element_blank(), #element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.ticks.x = element_blank(), 
        legend.position = "right", 
        axis.text.y=element_text(size=7.25), 
        plot.title = element_text(size=10),
        legend.text=element_text(size=6), 
        legend.title = element_text(size=6)) +
  ylab("Enriched Gene Ontology (GO) Term") + 
  ggtitle(NULL) + 
  annotate("text", x = 1, y = -.25, label = "Ambient\nvs. Moderate", size=2.25, col="gray15") +  
  annotate("text", x = 2, y = -.25, label = "Ambient\nvs. Low", size=2.25, col="gray15") +  
  annotate("text", x = 3, y = -.25, label = "Moderate\nvs. Low", size=2.25, col="gray15") +  
  coord_cartesian(clip = "off", ylim = c(-.6, 27.25))
#dev.off()

# Cellular components
#pdf(file="Enriched_CC_DEGs.pdf", height = 5.5, width = 6)
ggplot(gene_sets.CC %>% filter(gene_set %!in% modules) %>% droplevels() %>% 
          filter(name %in% unique(c(best_GO$`amb-mod_CC`$name, best_GO$`amb-low_CC`$name, best_GO$`mod-low_CC`$name))) %>%  # use only the best GO terms 
          #filter(p.adj<0.01) %>%
         mutate(name=as.factor(name)) %>% mutate(name=fct_reorder(name, delta.rank, .desc = TRUE)),  
#       aes(y=str_wrap(name),x=gene_set, col=gene_set_up)) + 
        aes(y=name,x=gene_set, col=gene_set_up)) + 
  geom_point(aes(alpha=p.adj, size=nseqs)) + #size=6,  
 facet_wrap(~category,scales="free", nrow = 2) +
  scale_color_manual(name="Upregulated", values=c(Ambient="#2c7bb6", Moderate="#fdae61", Low="#d7191c"),
             guide = guide_legend(override.aes = list(size=4))) +
  scale_alpha("FDR-adjusted\nP-value", range = c(1,0.35), #breaks = c(0, .25, .5, .75, 1), 
              guide = guide_legend(override.aes = list(size=4))) + 
  scale_size("Gene count", range = c(3,8), #breaks = c(2, 5, 10),
             guide = guide_legend(override.aes = list(col="gray50"))) +
  scale_x_discrete(drop=FALSE) +
  theme_cleveland() + 
  theme(axis.title.x=element_blank(), 
        axis.text.x = element_blank(),  #element_text(angle = 90, vjust = 0.5, hjust=1), 
        axis.ticks.x = element_blank(), 
        legend.position = "right", 
        axis.text.y=element_text(size=7.25), 
        plot.title = element_text(size=10),
        legend.text=element_text(size=6), 
        legend.title = element_text(size=6)) +
  ylab("Enriched Gene Ontology (GO) Term") + 
  ggtitle(NULL) +
  annotate("text", x = 1, y = -.05, label = "Ambient\nvs. Moderate", size=2.25, col="gray15") +  
  annotate("text", x = 2, y = -.05, label = "Ambient\nvs. Low", size=2.25, col="gray15") +  
  annotate("text", x = 3, y = -.05, label = "Moderate\nvs. Low", size=2.25, col="gray15") +  
  coord_cartesian(clip = "off", ylim = c(-0.1, 4))
#dev.off()
```

```{r}
gene_sets.MF %>% filter(gene_set %!in% modules) %>% arrange(name)
```



```{r}
module.lineplots[[1]]
```
### Identify GO ID that was selected to represent each group of GO terms. 

From the GO_MWU README file: "highly similar categories are merged according to complete linkage clustering based on the fraction of shared genes. The distance measure for clustering, introduced in Kosiol et al 2008, is the number of genes shared among the two GO categories within the analyzed dataset divided by the size of the smaller of the two categories. The resulting hierarchical tree is then “cut” at the adjustable “height” ('cutTreeHeight' parameter in the call to gomwuStats) to merge clustered categories. The default for cutTreeHeight is 0.25, implying that a group of categories will be merged if the most dissimilar two of them share >75% of genes included in the smaller of the two. **The merged categories inherit the name of the largest one.**" 

So, the GO_MWU results use terms that "represent" similar terms (and not GO_SLIMs). GO_MWU doesn't specify which GO ID was used (it just uses the name), so first I need to match the IDs to the names. 

```{r}
#Here I import the go.obo object and convert to dataframe. 
install.packages("ontologyIndex")
require(ontologyIndex)
ontology <- get_ontology("go.obo") %>% as.data.frame()
goslims <- get_ontology("goslim_plant.obo") %>% as.data.frame()

# Identify the representative GO ID selected for each group of merged IDs, column "id"
gene_sets.BP %>% left_join(ontology, by="name")
```
## Map GO terms to GO Slims 

```{r}
# Biological Processes
myIds <- (gene_sets.BP %>% left_join(ontology, by="name") %>% 
            filter(!is.na(term)))$term %>% unique()

myCollection <- GOCollection(myIds)
fl <- system.file("extdata", "goslim_plant.obo", package="GSEABase")
slim <- getOBOCollection(fl)

# Sets ontology category to "Molecular Function". Use "BP" for "Biological Process"
slimdf <- goSlim(myCollection, slim, ontology = "BP")

# This should match the ontology used above.
# E.g. GOBPOFFSPRING or GOCCOFFSPRING
GO.db::GOBPOFFSPRING

mappedIds <-
  function(df, collection, OFFSPRING)
  {
    map <- as.list(OFFSPRING[rownames(df)])
    mapped <- lapply(map, intersect, ids(collection))
    df[["go_terms"]] <- vapply(unname(mapped), paste, collapse = ";", character(1L))
    df
  }

slimdf <- mappedIds(slimdf, myCollection, GOBPOFFSPRING)
slimdf %>% filter(Count>0) %>% View()

write.csv(slimdf %>% filter(Count>0), file = "slim_bp.csv", quote = FALSE)
```

```{r}
## Molecular Functions 

myIds <- (gene_sets.MF %>% filter(gene_set %in% "amb-low") %>% 
            droplevels() %>% separate_rows(term, sep = ";") %>% 
            filter(!is.na(term)))$term %>% unique()
myCollection <- GOCollection(myIds)
fl <- system.file("extdata", "goslim_plant.obo", package="GSEABase")
slim <- getOBOCollection(fl)

# Sets ontology category to "Molecular Function". Use "BP" for "Biological Process"
slimdf <- goSlim(myCollection, slim, ontology = "MF")

# This should match the ontology used above.
# E.g. GOBPOFFSPRING or GOCCOFFSPRING
GO.db::GOMFOFFSPRING

mappedIds <-
  function(df, collection, OFFSPRING)
  {
    map <- as.list(OFFSPRING[rownames(df)])
    mapped <- lapply(map, intersect, ids(collection))
    df[["go_terms"]] <- vapply(unname(mapped), paste, collapse = ";", character(1L))
    df
  }

slimdf.AL <- mappedIds(slimdf, myCollection, GOMFOFFSPRING) %>% filter(Count>0)

left_join(
  slimdf.AL %>% separate_rows(go_terms, sep = ";") %>% dplyr::select(Term, go_terms),
  
  gene_sets.MF %>% filter(gene_set %in% "amb-mod") %>% 
            droplevels() %>% separate_rows(term, sep = ";") %>%
    dplyr::select(gene_set, delta.rank, p.adj, term, name, gene_set_up),
  by=c("go_terms"="term")) %>% filter(Term != "molecular_function") %>% View()



#slimdf %>% filter(Count>0) %>% View()
#write.csv(slimdf.AM, file = "slim_bp.csv", quote = FALSE)
```

```{r}
sessionInfo()
require(metacoder)
```


```{r}
mc <- "https://cran.r-project.org/src/contrib/Archive/metacoder/metacoder_0.1.3.tar.gz"
install.packages(mc, repos=NULL, type="source") ## version 1.3 is the only version compatible with the code below

install.packages("traits")
detach(package:metacoder, unload = TRUE)
devtools::install_github("https://github.com/grunwaldlab/metacoder/releases/tag/v0.3.1")


install.packages("metacoder")
install.packages("org.Hs.eg.db")
install.packages("airway")
install.packages("AnnotationDbi")

library(GO.db)
require(metacoder)
library(org.Hs.eg.db)
library(airway)
library(AnnotationDbi)

package.version("metacoder")

# set module of interest
module <- "orange" # lightsteelblue1  orange  paleturquoise

##### READ IN ALL MODULE GENE:GO INFORMATION #####
## get list of all GO IDs and corresponding terms
terms <- Term(GOTERM)
terms <- as.data.frame(terms)
terms <- cbind(rownames(terms), terms)
rownames(terms) <- c()
colnames(terms) <- c("go.id","term")
```
```{r}
gene_sets.BP %>% left_join(ontology, by="name") %>% filter(gene_set=="amb-low") %>% filter(gene_set_up == "Low") %>% dplyr::rename("ID"="id")

bpdata <- as.data.frame(final.go$ID)
```


```{r}
# ## get list of gene:GO term relationships
# ##
# ## gene.name       go.id
# ##
# rep.mods <- read.csv("/Users/Avril/Documents/rna_seq/seq_data_processing_notes_and_analyses/wgcna/go_for_janna/rep4_module_gene_go_info.csv")
# ## keep info for module of interest
# rep.mods <- rep.mods[which(rep.mods$module==module),]
# rep.mods$go.id <- as.character(rep.mods$go.id)
# rep.mods <- rep.mods[,c(2,4)]


##### GET GO TERMS UNIQUE TO MODULE OF INTEREST #####
##
## ID       term       count
##
#uni.terms <- read.csv(paste0(module,"_unique_GO_terms.csv"))
uni.terms <- gene_sets.BP %>% left_join(ontology, by="name") %>% filter(gene_set=="amb-low") %>% filter(gene_set_up == "Low") %>% dplyr::rename("ID"="id")

##### GET LIST OF INTERESTING GO TERMS (filt.go) THAT ARE ALSO UNIQUE TO MODULE #####
n <- 30 ## can limit the # of GO terms you want to include, just to see how it runs
n <- nrow(uni.terms)
final.go <- head(uni.terms, n=n)
# final.go <- uni.terms[which(uni.terms$ID %in% filt.go),]
# rm(list=ls()[! ls() %in% c("final.go","module")])

##### PASS FINAL GO LIST TO METACODER TO PLOT TREES #####
#setwd("~/Desktop/")

bpdata <- as.data.frame(final.go$ID)
colnames(bpdata) = c("GO.ID")
bpdata$GO.ID <- as.character(bpdata$GO.ID)

x <- bpdata$GO.ID

?type()

#function needed to parse GO IDs
term_class = function(x, current=x, all_paths = FALSE, type = GOBPPARENTS, verbose = TRUE, valid_relationships = c("is_a")) {
  # Get immediate children of current taxon
  parents = tryCatch({
    possible_parents <- as.list(type[x[1]])[[1]] #this line doesn't function?
    if (! is.null(valid_relationships)) {
      possible_parents <- possible_parents[names(possible_parents) %in% valid_relationships]
    }
    names(AnnotationDbi::Term(possible_parents))
  }, error = function(e) {
    c()
  })
  
  # only go down one path if desired
  if (! all_paths) {
    parents <- parents[1]
  }
  parents <- parents[parents != "all"]
  
  if (is.null(parents)) {
    return(c())
  } else if (length(parents) == 0) {
    cat(length(x))
    return(paste0(collapse = "|", AnnotationDbi::Term(x)))
  } else {
    next_x <- lapply(parents, function(y) c(y, x))
    
    # Run this function on them to get their output
    child_output <- lapply(next_x, term_class, all_paths = all_paths, type = type)
    output <- unlist(child_output, recursive = FALSE)
    
    return(output)
  }
}

#modify, pull go term relationships
bpterms = lapply(bpdata$GO.ID, term_class, all_paths = FALSE, type = GOBPPARENTS) #this line can take forever
bpres   = data.frame(class=unlist(bpterms))

#write/write data (annoyingly the only way I can get it to work, but at least it works)
write.table(bpres, "temp.csv", sep=",", col.names=TRUE, row.names=FALSE)
bpres=read.table("temp.csv", header=TRUE, sep=",")

## bpdata contains the GO IDs for the terminal nodes
## bpres and bpdata contain the same information, different formats = path information for each terminal node (GO Terms)

#parse GO data
data = parse_taxonomy_table("temp.csv",
                            taxon_col = c("class" = -1),
                            other_col_type = "obs_info",
                            sep=",",
                            class_sep = "\\|")

# parse GO data (parse_taxonomy_table replaced by taxa::parse_tax_data)
# data <- parse_tax_data(bpres,
#                        class_sep = "\\|")


#create figure
tempdata = filter_taxa(data, n_supertaxa <= 500) #filters terms that are WAAAAY out from the middle
## n_supertaxa sets # of nodes that can be in a single path from center to terminal nodes (cuts from terminal end, not internal nodes)

# pdf(paste("output/",module,"meta_labels.pdf", sep=""), width=5, height=5, useDingbats=FALSE, onefile=FALSE)
#grey70      grey40      dodgerblue2 tomato2  chartreuse3  darkorchid2 yellow3 orange2 magenta1
par(bg=NA)
set.seed(100) ## seeds: orange = 35       lightsteelblue1 = 75       paleturquoise = 100
heat_tree(tempdata, node_label = tempdata$taxon_data$name,
          # node_size = colsandsize$ngenes,
          # node_size_trans = "log10",
          node_size_range = c(0.01, 0.01),
          # node_label_size_trans = "log10",
          node_label_size_range = c(0.01, 0.01),
          # edge_size_trans = "log10",
          edge_size_range = c(0.004, 0.004),
          node_color = module,
          # node_color_trans = "linear",
          # node_color_range = diverging_palette(),
          # node_color_interval = c(-4, 4),
          # edge_color_trans = "linear",
          # edge_color_range = diverging_palette(),
          # edge_color_interval =  c(-4, 4),
          node_label_max = 500,
          # node_color_axis_label = "Factor change",
          # node_size_axis_label = "Number of genes",
          layout = "da", initial_layout = "re"
)
# dev.off()



## run this version to find best seed #s for each module's tree - have to highlight and run manually :/
# par(bg=NA)
# sede <- sample(1:100,1)
# pdf(paste0("/Users/Avril/Desktop/",module,"/",sede,".pdf"), width=5, height=5, useDingbats=FALSE, onefile=F)
# set.seed(sede) #grey70      grey40      dodgerblue2 tomato2  chartreuse3  darkorchid2 yellow3 orange2 magenta1
# heat_tree(tempdata, #node_label = tempdata$taxon_data$name,
#           # node_size = colsandsize$ngenes,
#           # node_size_trans = "log10",
#           node_size_range = c(0.01, 0.01),
#           # node_label_size_trans = "log10",
#           node_label_size_range = c(0.01, 0.01),
#           # edge_size_trans = "log10",
#           edge_size_range = c(0.004, 0.004),
#           node_color = module,
#           # node_color_trans = "linear",
#           # node_color_range = diverging_palette(),
#           # node_color_interval = c(-4, 4),
#           # edge_color_trans = "linear",
#           # edge_color_range = diverging_palette(),
#           # edge_color_interval =  c(-4, 4),
#           node_label_max = 500,
#           # node_color_axis_label = "Factor change",
#           # node_size_axis_label = "Number of genes",
#           layout = "da", initial_layout = "re"
# )
# dev.off()

```


```{r}
bioconductor.packages <- c("Go.db", "org.Hs.eg.db", "airway", "rnaseqGene")

# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
new.bioc.packages <- bioconductor.packages[!(bioconductor.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
if(length(new.bioc.packages)) BiocManager::install(new.bioc.packages)
```

```{r}
term_class <- function(x, current = x, all_paths = TRUE, type = GOCCPARENTS, verbose = TRUE, 
                       valid_relationships = c("is_a")) {
  # Get immediate children of current taxon
  parents = tryCatch({
    possible_parents <- as.list(type[x[1]])[[1]]
    if (! is.null(valid_relationships)) {
      possible_parents <- possible_parents[names(possible_parents) %in% valid_relationships]
    }
    names(AnnotationDbi::Term(possible_parents))
  }, error = function(e) {
    c()
  })
  
  # only go down one path if desired
  if (! all_paths) {
    parents <- parents[1]
  }
  parents <- parents[parents != "all"]
  
  if (is.null(parents)) {
    return(c())
  } else if (length(parents) == 0) {
    return(paste0(collapse = "|", AnnotationDbi::Term(x)))
  } else {
    next_x <- lapply(parents, function(y) c(y, x))
    
    # Run this function on them to get their output
    child_output <- lapply(next_x, term_class, all_paths = all_paths, type = type)
    output <- unlist(child_output, recursive = FALSE)
    
    return(output)
  }
}
```


## Try to use metacor 

```{r}
devtools::install_github("grunwaldlab/metacoder")

# eXAMPLE DATA 
library(rnaseqGene)
library(airway)
library(GO.db)
library(org.Hs.eg.db)
library(DESeq2)
library(metacoder)

min_p_value <- 0.05
data("airway")
se <- airway
se$dex <- relevel(se$dex, "untrt")
se$dex

dds <- DESeqDataSet(se, design = ~ cell + dex)
dds <- dds[ rowSums(counts(dds)) > 1, ]
rld <- rlog(dds, blind=FALSE)
dds <- estimateSizeFactors(dds)
dds <- DESeq(dds)
res <- results(dds)
res$go_id <- mapIds(org.Hs.eg.db,
                    keys=rownames(res),
                    column="GO",
                    keytype="ENSEMBL",
                    multiVals="first")
res <- res[!is.na(res$go_id), ]
res <- res[res$go_id %in% keys(org.Hs.eg.db, keytype = "GO"), ]
res <- res[(! is.na(res$padj)) & res$padj <= 0.05, ]
res <-  res[abs(res$log2FoldChange) >= 0.5, ]

head(res)


cc_class <- lapply(res$go_id, term_class, all_paths = FALSE, type = GOCCPARENTS)
mf_class <- lapply(res$go_id, term_class, all_paths = FALSE, type = GOMFPARENTS)
bp_class <- lapply(res$go_id, term_class, all_paths = FALSE, type = GOBPPARENTS)

cc_class <- lapply(res$go_id, term_class, all_paths = FALSE, type = GOCCPARENTS)
(cc_res <- res[rep(1:nrow(res), sapply(cc_class, length)), ])
cc_res$class <- unlist(cc_class)

bp_res <- res[rep(1:nrow(res), sapply(bp_class, length)), ]
bp_res$class <- unlist(bp_class)

mf_res <- res[rep(1:nrow(res), sapply(mf_class, length)), ]
mf_res$class <- unlist(mf_class)

# 
obj <- metacoder::parse_tax_data(as.data.frame(cc_res), class_cols = "class", class_sep = "|")
obj$funcs <- c(obj$funcs,
               change = function(x, subset = NULL) {
                 vapply(obs(x, "tax_data"),
                        function(i) {
                          obs_change <- obj$data$tax_data[i, ]$log2FoldChange[obj$data$tax_data[i, ]$padj <= min_p_value]
                          mean(obs_change, na.rm = TRUE)
                        },
                        numeric(1))
               },
               num_changed = function(x, subset = NULL) {
                 vapply(obs(x, "tax_data"),
                        function(i) {
                          sum(obj$data$tax_data[i, ]$padj <= min_p_value, na.rm = TRUE)
                        },
                        numeric(1))
               })

set.seed(3)
obj %>%
  filter_taxa(num_changed > 0) %>%
  filter_taxa(n_supertaxa <= 4) %>%
  # filter_taxa(n_supertaxa >= 1) %>% 
  # filter_taxa(nchar(taxon_names) <= 40) %>%
  heat_tree(node_label = ifelse(nchar(taxon_names) <= 50, taxon_names, ""),
            node_size = num_changed,
            # node_size_trans = "log10",
            node_size_range = c(0.01, 0.03),
            # node_label_size_trans = "log10",
            node_label_size_range = c(0.01, 0.02),
            # edge_size_trans = "log10",
            edge_size_range = c(0.008, 0.03) / 2,
            node_color = 2^abs(change) * sign(change),
            node_color_trans = "linear",
            node_color_range = diverging_palette(),
            node_color_interval = c(-4, 4),
            # edge_color_trans = "linear",
            # edge_color_range = diverging_palette(),
            # edge_color_interval =  c(-4, 4),
            # node_label_max = 500,
            node_color_axis_label = "Factor change",
            node_size_axis_label = "Number of genes",
            layout = "da", initial_layout = "re",
            output_file = "test")
```


```{r}
cc_class <- lapply(uni.terms$ID, term_class, all_paths = FALSE, type = GOCCPARENTS)
mf_class <- lapply(uni.terms$ID, term_class, all_paths = FALSE, type = GOMFPARENTS)
bp_class <- lapply(uni.terms$ID, term_class, all_paths = FALSE, type = GOBPPARENTS)  
```

```{r}
term_class()
x <- res$go_id
# Get immediate children of current taxon
  parents = tryCatch({
    possible_parents <- as.list(type[x[1]])[[1]]
    if (! is.null(valid_relationships)) {
      possible_parents <- possible_parents[names(possible_parents) %in% valid_relationships]
    }
    names(AnnotationDbi::Term(possible_parents))
  }, error = function(e) {
    c()
  })
  
  # only go down one path if desired
  if (! all_paths) {
    parents <- parents[1]
  }
  parents <- parents[parents != "all"]
  
  if (is.null(parents)) {
    return(c())
  } else if (length(parents) == 0) {
    return(paste0(collapse = "|", AnnotationDbi::Term(x)))
  } else {
    next_x <- lapply(parents, function(y) c(y, x))
    
    # Run this function on them to get their output
    child_output <- lapply(next_x, term_class, all_paths = all_paths, type = type)
    output <- unlist(child_output, recursive = FALSE)
    
    return(output)
  }
```


# Standard GO_MWU analysis (Fischer Exact Test) to look at enrichment of low Coeff. Variation upregulated DEGs, perhaps critical to function in OA?

This function performs standard GO enrichment analysis based on Fisher's exact test, using binary measure (1 or 0, i.e., either sgnificant or not). 


```{r}
go.mwu.standard <- function(file) {
  
  input = file
  goAnnotations = "DESeq-genes_for-GOMWU.tab"

for (j in 1:length(goDivisions)) {
  tryCatch({
  
# ------------- Calculating stats
# It might take a few minutes for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.

gomwuStats(input, goDatabase, goAnnotations, goDivisions[j],
	perlPath="C:/Strawberry/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
	#largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
	#smallest=5,   # a GO category should contain at least this many genes to be considered
	clusterCutHeight=0.30, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
	#Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.


# ----------- Plotting results

#quartz()
results=gomwuPlot(input,goAnnotations,goDivisions[j],
 	#absValue=-log(0.05,10),   # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
 absValue=0.001,
 	#absValue=.5, # un-remark this if you are using log2-fold changes
 #level1=0.05,level2=0.01,level3=0.001,	#stricter settings for many GO terms 
 #level1=0.1, # FDR threshold for plotting. 
 	#level2=.05, # FDR cutoff to print in regular (not italic) font.
 	#level3=.01, # FDR cutoff to print in large bold font.
  level1=1, level2=0.2, level3=0.05, # Specify level1=1 to plot all GO categories containing genes exceeding the absValue.

 	txtsize=1,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
 	treeHeight=0.5, # height of the hierarchical clustering tree
 	#colors=c(color, color, color, color, color)
 colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
 )
mtext(paste(contrast, " - ", goDivisions[j], sep=""), side = 3, line = 3, adj = -.05, col="black")
 # manually rescale the plot so the tree matches the text 
 # if there are too many categories displayed, try make it more stringent with level1=0.05,level2=0.01,level3=0.001.  
 
 # text representation of results, with actual adjusted p-values
 print(results[[1]])


# ------- extracting representative GOs

# this module chooses GO terms that best represent *independent* groups of significant GO terms

pcut=1e-2 # adjusted pvalue cutoff for representative GO
hcut=0.9 # height at which cut the GO terms tree to get "independent groups". 

# plotting the GO tree with the cut level (un-remark the next two lines to plot)
# plot(results[[2]],cex=0.6)
# abline(h=hcut,col="red")

# cutting
ct=cutree(results[[2]],h=hcut)
annots=c();ci=1
for (ci in unique(ct)) {
  message(ci)
	rn=names(ct)[ct==ci]
	obs=grep("obsolete",rn)
	if(length(obs)>0) { rn=rn[-obs] }
	if (length(rn)==0) {next}
	rr=results[[1]][rn,]
	bestrr=rr[which(rr$pval==min(rr$pval)),]
	best=1
	if(nrow(bestrr)>1) {
		nns=sub(" .+","",row.names(bestrr))
		fr=c()
		for (i in 1:length(nns)) { fr=c(fr,eval(parse(text=nns[i]))) }
		best=which(fr==max(fr))
	}
	if (bestrr$pval[best]<=pcut) { annots=c(annots,sub("\\d+\\/\\d+ ","",row.names(bestrr)[best]))}
}

mwus=read.table(paste("MWU",goDivisions[j],input,sep="_"),header=T)
bestGOs=mwus[mwus$name %in% annots,]
print(bestGOs)
},
error=function(e){cat("ERROR:", conditionMessage(e), "\n")})
}
}
```

```{r}
go.mwu.standard(file = "DEGs-upreg-lowCV_amb-mod.csv")
```

```{r}
go.mwu.standard(file = "DEGs-upreg-lowCV_amb-low.csv")
```

```{r}
go.mwu.standard(file = "DEGs-upreg-lowCV_amb.csv")
```

